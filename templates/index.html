<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kalorick√© Tabulky - Studijn√≠ Vyhled√°vaƒç</title>
    <!-- Odkaz na extern√≠ CSS soubor -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body data-app-id="{{ app_id }}" data-firebase-config="{{ firebase_config_json }}">
    <div class="container">
        <!-- Nov√Ω wrapper pro statick√© z√°hlav√≠ -->
        <div class="sticky-header-wrapper">
            <div id="userIdDisplay"></div> <!-- P≈ôesunuto sem -->
            <h1>Kalorick√° kalkulaƒçka</h1>

            <!-- Ikonka ozuben√©ho koleƒçka pro nastaven√≠ (PNG obr√°zek) -->
            <img id="settingsIcon" src="{{ url_for('static', filename='icon/nastaveni.png') }}" alt="Nastaven√≠" class="settings-icon">

            <!-- Kontejner pro zarovn√°n√≠ tlaƒç√≠tka "Recepty" a vyhled√°v√°n√≠ -->
            <div class="search-and-recipes-container">
                <div class="main-controls">
                    <button id="recipesButton" disabled>Recepty</button>
                    <!-- P≈ôid√°me tlaƒç√≠tko pro skenov√°n√≠ ƒç√°rov√Ωch k√≥d≈Ø -->
                    <button id="barcodeButton" style="margin-left: 10px;">
                        üì∑ Skenovat k√≥d
                    </button>
                </div>

                <form id="searchForm">
                    <input type="text" id="query" name="query" placeholder="Zadejte n√°zev potraviny (nap≈ô. jablko, ku≈ôe)">
                    <button type="submit">Vyhledat</button>
                </form>
            </div>

            <div id="loading">Vyhled√°v√°m...</div>
            <div id="error-message" class="error"></div>
        </div>

        <div id="results">
            <!-- Zde se budou zobrazovat v√Ωsledky -->
        </div>
    </div>

    <!-- Mod√°ln√≠ okno pro detaily potravin a recept≈Ø (adaptov√°no) -->
    <div id="detailsModal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-button">&times;</span>

            <!-- P≈ôid√°me speci√°ln√≠ t≈ô√≠du pouze pro recepty -->
            <div id="modalDetailsContent" class="modal-details modal-recipe-container">
    <!-- Fixn√≠ hlaviƒçka receptu -->
    <div class="modal-recipe-header">
        <img id="modalHeaderImage" src="{{ url_for('static', filename='icon/recepty.png') }}" alt="" class="modal-header-image">
        <div class="modal-header-text">
            <div id="modalHeaderName" class="modal-header-name">N√°zev receptu</div>
            <div class="energy-display-group">
                <div id="totalKcalDisplay" class="energy-header">0 kcal</div>
                <div id="totalKjDisplay" class="energy-sub-header">0 kJ</div>
            </div>
        </div>
    </div>

    <!-- Hlavn√≠ obsah s scrollov√°n√≠m -->
    <div class="modal-scrollable-container">
        <div id="nutrientDetailsSection"></div>
        <h3 class="ingredients-title">Slo≈æen√≠ receptu:</h3>
        <div id="recipeIngredientsList"></div>
    </div>
</div>

        </div>
    </div>

    <!-- Nov√© mod√°ln√≠ okno pro vytvo≈ôen√≠ nov√©ho receptu -->
    <div id="createRecipeModal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-button" id="closeCreateRecipeModal">&times;</span>
            <h3>Vytvo≈ôit nov√Ω recept</h3>
            <input type="text" id="newRecipeNameInput" placeholder="N√°zev receptu">
            <div class="create-recipe-buttons"> <!-- Nov√Ω kontejner pro tlaƒç√≠tka -->
                <button id="confirmCreateRecipeButton">Vytvo≈ôit a p≈ôidat</button>
                <button id="cancelCreateRecipeButton">Zru≈°it</button>
            </div>
        </div>
    </div>

    <!-- Nov√© mod√°ln√≠ okno pro v√Ωbƒõr existuj√≠c√≠ho receptu -->
    <div id="selectRecipeModal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-button" id="closeSelectRecipeModal">&times;</span>
            <h3>Moje recepty</h3>
            <!-- Nov√Ω element pro zobrazen√≠ poƒçtu recept≈Ø -->
            <div id="recipeCountDisplay" class="recipe-count-display"></div>
            <ul id="existingRecipesList">
                <!-- Recepty se naƒçtou zde -->
            </ul>
            <div class="recipe-list-actions">
                <!-- Tlaƒç√≠tko "P≈ôidat nov√Ω recept" je nyn√≠ skryto nebo odstranƒõno -->
                <!-- Tlaƒç√≠tko "Zav≈ô√≠t" je odstranƒõno -->
            </div>
        </div>
    </div>

    <!-- Nov√© mod√°ln√≠ okno pro vlastn√≠ upozornƒõn√≠ -->
    <div id="customNotificationModal" class="modal-overlay">
        <div class="modal-content">
            <p id="customNotificationMessage"></p>
            <div class="notification-controls">
                <div id="dynamicNotificationToggleContainer" class="notification-toggle-container">
                    <!-- Dynamic toggle will be inserted here by JS -->
                </div>
                <!-- Tlaƒç√≠tka pro potvrzen√≠/zru≈°en√≠ se budou dynamicky vkl√°dat zde -->
            </div>
        </div>
    </div>

    <!-- Nov√© mod√°ln√≠ okno pro nastaven√≠ -->
    <div id="settingsModal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-button" id="closeSettingsModal">&times;</span>
            <h3>Nastaven√≠</h3>
            <div class="setting-item">
                <span class="setting-label">Potvrzen√≠ smaz√°n√≠ receptu</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmDeleteRecipeToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Potvrzen√≠ smaz√°n√≠ polo≈æky</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmDeleteRecipeItemToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Potvrzen√≠ ulo≈æen√≠ zmƒõn</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmSaveChangesToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Ozn√°men√≠ vytvo≈ôen√≠ receptu</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmRecipeCreationToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Ozn√°men√≠ p≈ôid√°n√≠ potraviny</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmFoodAdditionToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Ozn√°men√≠ √∫spƒõ≈°n√©ho smaz√°n√≠</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmRecipeDeletionSuccessToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Ozn√°men√≠ chyby smaz√°n√≠</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmRecipeDeletionErrorToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Ozn√°men√≠ √∫spƒõ≈°n√©ho ulo≈æen√≠ zmƒõn</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmRecipeSaveSuccessToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>

    <!-- Nov√© mod√°ln√≠ okno pro skenov√°n√≠ ƒç√°rov√Ωch k√≥d≈Ø -->
    <div id="barcodeModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 90%; height: 70%;">
            <span class="close-button" id="closeBarcodeModal">&times;</span>
            <h3>Skenovat ƒç√°rov√Ω k√≥d</h3>
            <button id="stopScanButton" style="margin: 10px auto; display: block; padding: 10px 20px; 
                    background-color: #f44336; color: white; border: none; border-radius: 8px; 
                   cursor: pointer; display: none;">
                Zastavit skenov√°n√≠
            </button>
            <div id="barcodeScannerContainer" style="width: 100%; height: 80%; position: relative; display: flex; justify-content: center; align-items: center; background-color: #f0f0f0; border-radius: 8px;">
                <div id="barcodeUnsupportedMessage" style="text-align: center; padding: 20px;">
                    <p style="font-size: 18px; margin-bottom: 15px;">üîí Skenov√°n√≠ ƒç√°rov√Ωch k√≥d≈Ø nen√≠ v tomto prohl√≠≈æeƒçi dostupn√©</p>
                    <p style="margin-bottom: 10px;">Pro skenov√°n√≠ k√≥d≈Ø fotoapar√°tem:</p>
                    <ul style="text-align: left; margin-bottom: 15px;">
                        <li>Pou≈æijte HTTPS p≈ôipojen√≠ (zabezpeƒçen√©)</li>
                        <li>Povolte p≈ô√≠stup ke kame≈ôe v prohl√≠≈æeƒçi</li>
                        <li>Zkuste modern√≠ prohl√≠≈æeƒç (Chrome, Firefox, Edge)</li>
                    </ul>
                    <p>M≈Ø≈æete tak√© zadat k√≥d ruƒçnƒõ:</p>
                    <input type="text" id="manualBarcodeInput" placeholder="Zadejte ƒç√°rov√Ω k√≥d" style="padding: 10px; width: 200px; border: 1px solid #ddd; border-radius: 4px; margin-right: 10px;">
                    <button id="submitManualBarcode" style="padding: 10px 15px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Vyhledat</button>
                </div>
                <video id="barcodeVideo" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px; display: none;"></video>
                <canvas id="barcodeCanvas" style="display: none;"></canvas>
                <div id="barcodeOverlay" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 70%; height: 30%; border: 2px solid #4CAF50; border-radius: 8px; pointer-events: none; display: none;"></div>
            </div>
            <div style="margin-top: 15px; text-align: center;">
                <button id="toggleCameraButton" style="margin: 0 5px; display: none;">P≈ôepnout kameru</button>
                <button id="toggleFlashButton" style="margin: 0 5px; display: none;">Blesk</button>
            </div>
            <div id="barcodeStatus" style="text-align: center; margin-top: 10px; color: #666;"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>

    <script type="module">
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, addDoc, collection, query, where, getDocs, deleteDoc, serverTimestamp, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables for Firebase (provided by Canvas environment)
        const bodyElement = document.body;
        const appId = bodyElement.dataset.appId;
        const firebaseConfigString = bodyElement.dataset.firebaseConfig;

        console.log("DEBUG JS: Raw appId from data attribute:", appId);
        console.log("DEBUG JS: Raw firebaseConfigString from data attribute:", firebaseConfigString);

        let firebaseConfig = {};
        try {
            firebaseConfig = JSON.parse(firebaseConfigString);
            console.log("DEBUG JS: Parsed firebaseConfig object:", firebaseConfig);
            console.log("DEBUG JS: firebaseConfig.projectId:", firebaseConfig.projectId);
            console.log("DEBUG JS: firebaseConfig.apiKey:", firebaseConfig.apiKey);
        } catch (e) {
            console.error("DEBUG JS: Error parsing firebaseConfigString:", e);
            console.error("DEBUG JS: firebaseConfigString that failed to parse:", firebaseConfigString);
        }

        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;


        const commonMisreads = {
        '3921244567890': '6901234567843',
        '12526048': '8595229926818',
        '12345678': '8594001000108',
        '21107887': '6901234567843', // Novƒõ detekovan√Ω k√≥d
        // P≈ôidejte dal≈°√≠ ƒçast√© chyby ƒçten√≠
        };



        let app, db, auth, userId;
        let isAuthReady = false;
        let userSettings = {
            confirmRecipeCreation: true, // Default value
            confirmFoodAddition: true, // Default value
            confirmDeleteRecipe: true, // New default value for delete confirmation
            confirmDeleteRecipeItem: true, // New setting for deleting recipe items
            confirmSaveChanges: true, // Re-added
            confirmRecipeSaveSuccess: true, // Re-added
            confirmRecipeDeletionSuccess: true, // New setting for success message
            confirmRecipeDeletionError: true // New setting for error message
        };

        // Declare currentFoodItemData in global scope
        let currentFoodItemData = null; // To store data of the food item being processed
        let currentEditingRecipeId = null; // Store the ID of the recipe being edited
        let currentEditingIngredientIndex = null; // Store the index of the ingredient being edited
        const placeholderImage = "{{ url_for('static', filename='icon/potraviny.png') }}"; // Add this line

// P≈òIDEJTE TUTO FUNKCI - mus√≠ b√Ωt v glob√°ln√≠m scope
function searchByBarcode(barcode) {
    console.log('Vyhled√°v√°m podle ƒç√°rov√©ho k√≥du:', barcode);
    
    // Nastav√≠me hodnotu do vyhled√°vac√≠ho pole
    const searchInput = document.getElementById('query');
    if (searchInput) {
        searchInput.value = barcode;
    }
    
    // Spust√≠me vyhled√°v√°n√≠
    const searchForm = document.getElementById('searchForm');
    if (searchForm) {
        // Vytvo≈ô√≠me a ode≈°leme submit event
        const submitEvent = new Event('submit', { 
            bubbles: true, 
            cancelable: true 
        });
        searchForm.dispatchEvent(submitEvent);
    } else {
        console.error('Search form element not found');
    }
}


        // --- Helper functions (Moved to global scope) ---
        function parseValueAndUnit(valueString) {
            if (typeof valueString !== 'string' && typeof valueString !== 'number') {
                return { number: NaN, unit: '' };
            }
            if (typeof valueString === 'number') {
                return { number: valueString, unit: '' };
            }

            const cleanedString = String(valueString).replace(/[\s\u00A0]/g, '').replace(',', '.');
            const match = cleanedString.match(/(\d+\.?\d*)\s*(.*)/);

            if (match) {
                const number = parseFloat(match[1]);
                const unit = match[2] || '';
                return { number, unit };
            }
            return { number: NaN, unit: '' };
        }

        function formatNumberForDisplay(number, unit = '', isEnergyValue = false) {
            if (typeof number !== 'number' || isNaN(number) || number === null || number === undefined) {
                return '-';
            }

            let formattedNumber;
            if (isEnergyValue) {
                // For energy values (kcal, kJ), round to 1 decimal place
                formattedNumber = parseFloat(number.toFixed(1));
            } else {
                // For other nutrients, keep 2 decimal places as before
                formattedNumber = parseFloat(number.toFixed(2));
            }

            // Use toLocaleString for proper locale-specific formatting (e.g., comma as decimal separator)
            return `${formattedNumber.toLocaleString('cs-CZ')}${unit ? ` ${unit}` : ''}`;
        }

        function createNutrientRow(label, originalValueString, rdiString = null, dotColor = null, type = 'other', currentFactor = 1, addSeparator = false, fontWeight = 'bold', fontSize = null) {
            const { number: originalNumericValue, unit: displayUnit } = parseValueAndUnit(originalValueString);

            let calculatedValueDisplay;
            if (isNaN(originalNumericValue)) {
                calculatedValueDisplay = '-';
            } else {
                calculatedValueDisplay = formatNumberForDisplay(originalNumericValue * currentFactor, displayUnit, false);
            }

            let dot = dotColor ? `<span class="dot ${dotColor}"></span>` : '';
            let labelClass = 'nutrient-label';
            let valueClass = 'nutrient-value';

            let labelStyle = `font-weight: ${fontWeight};`;
            let valueStyle = `font-weight: ${fontWeight};`;
            let separatorHtml = '';

            if (fontSize) {
                labelStyle += `font-size: ${fontSize};`;
                valueStyle += `font-size: ${fontSize};`;
            }

            if (dotColor) {
                let colorHex = '';
                switch (dotColor) {
                    case 'red': colorHex = '#f44336'; break;
                    case 'blue': colorHex = '#2196f3'; break;
                    case 'orange': colorHex = '#ff9800'; break;
                    case 'green': colorHex = '#4caf50'; break;
                    default: colorHex = '';
                }
                if (colorHex) {
                    labelStyle += `color: ${colorHex};`;
                    valueStyle += `color: ${colorHex};`;
                }
            }

            if (type === 'main') {
                labelClass += ' main';
                valueClass += ' main-value';
            } else if (type === 'nested') {
                labelClass = 'nutrient-sub-label';
                valueClass = 'nutrient-sub-value';
            }

            if (addSeparator) {
                separatorHtml = `<div class="nutrient-line-separator"></div>`;
            }

            let rdiHtml = '';

            return `
                ${separatorHtml}
                <div class="nutrient-row">
                    <div class="${labelClass}" style="${labelStyle}">${dot}${label}</div>
                    <div class="${valueClass}" style="${valueStyle}">${calculatedValueDisplay}</div>
                </div>
                ${rdiHtml}
            `;
        }

        function renderAllNutrientDetails(details, factor = 1) {
            if (!details || typeof details !== 'object') {
                console.error("Neplatn√° nutriƒçn√≠ data");
                return;
            }

            // Upravte form√°tov√°n√≠ ƒç√≠sel:
            const formatValue = (value) => {
                if (value === "N/A") return "-";
                const num = parseFloat(value);
                return isNaN(num) ? value : num.toLocaleString('cs-CZ');
            };

            // Upravte v√Ωpoƒçet faktor≈Ø:
            const applyFactor = (value) => {
                if (value === "N/A") return "-";
                const num = parseFloat(value);
                return isNaN(num) ? value : (num * factor).toFixed(1);
            };
            console.log("renderAllNutrientDetails called with details:", details, "factor:", factor);
            const nutrientDetailsSection = document.getElementById('nutrientDetailsSection');
            if (!nutrientDetailsSection) {
                console.error("Element 'nutrientDetailsSection' not found. Cannot render nutrients.");
                return;
            }
            nutrientDetailsSection.innerHTML = '';

            const totalKcalDisplay = document.getElementById('totalKcalDisplay');
            const totalKjDisplay = document.getElementById('totalKjDisplay');

            if (totalKcalDisplay) {
                const { number: kcalNum, unit: kcalUnit } = parseValueAndUnit(details.total_kcal);
                totalKcalDisplay.textContent = formatNumberForDisplay(kcalNum * factor, kcalUnit, true);
            }
            if (totalKjDisplay) {
                const { number: kjNum, unit: kjUnit } = parseValueAndUnit(details.total_kj);
                totalKjDisplay.textContent = `Tak√© ${formatNumberForDisplay(kjNum * factor, kjUnit, true)} ‚Ä¢ Energetick√° hodnota`;
            }

            let nutrientsHtmlContent = '';

            nutrientsHtmlContent += `<div class="nutrient-section">`;
            nutrientsHtmlContent += createNutrientRow('B√≠lkoviny', details.protein, null, 'red', 'main', factor, true);
            nutrientsHtmlContent += createNutrientRow('Sacharidy', details.carbs, null, 'blue', 'main', factor, true);
            nutrientsHtmlContent += createNutrientRow('Cukry', details.sugar, null, null, 'nested', factor, false);
            nutrientsHtmlContent += createNutrientRow('Tuky', details.fat, null, 'orange', 'main', factor, true);
            nutrientsHtmlContent += createNutrientRow('Nasycen√© mastn√© kyseliny', details.saturated_fat, null, null, 'nested', factor, false);
            nutrientsHtmlContent += createNutrientRow('Trans mastn√© kyseliny', details.trans_fat, null, null, 'nested', factor, false);
            nutrientsHtmlContent += createNutrientRow('Mononenasycen√©', details.monounsaturated_fat, null, null, 'nested', factor, false);
            nutrientsHtmlContent += createNutrientRow('Polynenasycen√©', details.polyunsaturated_fat, null, null, 'nested', factor, false);
            nutrientsHtmlContent += createNutrientRow('Cholesterol', details.cholesterol, null, null, 'nested', factor, false);
            nutrientsHtmlContent += `</div>`;

            nutrientsHtmlContent += `<div class="nutrient-section">`;
            nutrientsHtmlContent += createNutrientRow('Vl√°knina', details.fiber, null, 'green', 'main', factor, true);
            nutrientsHtmlContent += `</div>`;

            nutrientsHtmlContent += `<div class="nutrient-section">`;
            nutrientsHtmlContent += createNutrientRow('S≈Øl', details.salt, null, null, 'main', factor, true, 'normal', '1.05em');
            nutrientsHtmlContent += createNutrientRow('V√°pn√≠k', details.calcium, null, null, 'main', factor, false, 'normal', '1.05em');
            nutrientsHtmlContent += createNutrientRow('Sod√≠k', details.sodium, null, null, 'main', factor, false, 'normal', '1.05em');
            nutrientsHtmlContent += createNutrientRow('Voda', details.water, null, null, 'main', factor, false, 'normal', '1.05em');
            nutrientsHtmlContent += createNutrientRow('PHE', details.phe, null, null, 'main', factor, false, 'normal', '1.05em');
            nutrientsHtmlContent += `</div>`;

            nutrientDetailsSection.innerHTML = nutrientsHtmlContent;
            console.log("Nutrients rendered.");
        }

        // Initialize Firebase and set up auth listener
        const initializeFirebase = async () => {
            try {
                if (Object.keys(firebaseConfig).length === 0 || !firebaseConfig.projectId || !firebaseConfig.apiKey) {
                    throw new Error("Firebase konfigurace je pr√°zdn√° nebo neplatn√° (chyb√≠ projectId/apiKey).");
                }

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Firebase Auth Ready. User ID:", userId);
                        await loadUserSettings(); // Load settings after user is authenticated
                    } else {
                        if (initialAuthToken) {
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                                userId = auth.currentUser.uid;
                                console.log("Signed in with custom token. User ID:", userId);
                                await loadUserSettings();
                            } catch (error) {
                                console.error("Error signing in with custom token:", error);
                                await signInAnonymously(auth);
                                userId = auth.currentUser.uid;
                                console.log("Signed in anonymously due to custom token error. User ID:", userId);
                                await loadUserSettings();
                            }
                        } else {
                            await signInAnonymously(auth);
                            userId = auth.currentUser.uid;
                            console.log("Signed in anonymously. User ID:", userId);
                            await loadUserSettings();
                        }
                    }
                    isAuthReady = true;
                    document.getElementById('userIdDisplay').textContent = `U≈æivatel ID: ${userId}`;

                    // Enable recipe buttons once auth is ready
                    document.getElementById('recipesButton').disabled = false;
                    
                    // Initialize barcode scanner after auth is ready
                    initBarcodeScanner();
                });
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                alert("Chyba p≈ôi inicializaci Firebase: " + error.message + " Zkuste pros√≠m aplikaci znovu naƒç√≠st.");
            }
        };

        // Function to load user settings from Firestore
        async function loadUserSettings() {
            if (!db || !userId) {
                console.warn("Firestore or User ID not available to load settings.");
                return;
            }
            try {
                const settingsDocRef = doc(db, `artifacts/${appId}/users/${userId}/settings/userSettings`);
                const settingsSnap = await getDoc(settingsDocRef);

                if (settingsSnap.exists()) {
                    userSettings = settingsSnap.data();
                    console.log("User settings loaded:", userSettings);
                } else {
                    // If no settings exist, create default ones
                    await setDoc(settingsDocRef, userSettings, { merge: true });
                    console.log("Default user settings created.");
                }
                // Update the UI toggles based on loaded settings
                const confirmRecipeCreationToggle = document.getElementById('confirmRecipeCreationToggle');
                const confirmFoodAdditionToggle = document.getElementById('confirmFoodAdditionToggle');
                const confirmDeleteRecipeToggle = document.getElementById('confirmDeleteRecipeToggle');
                const confirmDeleteRecipeItemToggle = document.getElementById('confirmDeleteRecipeItemToggle'); // NEW
                const confirmSaveChangesToggle = document.getElementById('confirmSaveChangesToggle'); // NEW
                const confirmRecipeSaveSuccessToggle = document.getElementById('confirmRecipeSaveSuccessToggle'); // NEW
                const confirmRecipeDeletionSuccessToggle = document.getElementById('confirmRecipeDeletionSuccessToggle');
                const confirmRecipeDeletionErrorToggle = document.getElementById('confirmRecipeDeletionErrorToggle');

                if (confirmRecipeCreationToggle) {
                    confirmRecipeCreationToggle.checked = userSettings.confirmRecipeCreation;
                }
                if (confirmFoodAdditionToggle) {
                    confirmFoodAdditionToggle.checked = userSettings.confirmFoodAddition;
                }
                if (confirmDeleteRecipeToggle) {
                    confirmDeleteRecipeToggle.checked = userSettings.confirmDeleteRecipe;
                }
                if (confirmDeleteRecipeItemToggle) { // NEW
                    confirmDeleteRecipeItemToggle.checked = userSettings.confirmDeleteRecipeItem;
                }
                if (confirmSaveChangesToggle) { // NEW
                    confirmSaveChangesToggle.checked = userSettings.confirmSaveChanges;
                }
                if (confirmRecipeSaveSuccessToggle) { // NEW
                    confirmRecipeSaveSuccessToggle.checked = userSettings.confirmRecipeSaveSuccess;
                }
                if (confirmRecipeDeletionSuccessToggle) {
                    confirmRecipeDeletionSuccessToggle.checked = userSettings.confirmRecipeDeletionSuccess;
                }
                if (confirmRecipeDeletionErrorToggle) {
                    confirmRecipeDeletionErrorToggle.checked = userSettings.confirmRecipeDeletionError;
                }
            } catch (error) {
                console.error("Error loading user settings:", error);
                // Fallback to default if loading fails
                userSettings = {
                    confirmRecipeCreation: true,
                    confirmFoodAddition: true,
                    confirmDeleteRecipe: true,
                    confirmDeleteRecipeItem: true, // Ensure default is set here too
                    confirmSaveChanges: true, // Ensure default is set here too
                    confirmRecipeSaveSuccess: true, // Ensure default is set here too
                    confirmRecipeDeletionSuccess: true,
                    confirmRecipeDeletionError: true
                };
            }
        }

        // Function to save user settings to Firestore
        async function saveUserSettings() {
            if (!db || !userId) {
                console.warn("Firestore or User ID not available to save settings.");
                return;
            }
            try {
                const settingsDocRef = doc(db, `artifacts/${appId}/users/${userId}/settings/userSettings`);
                await setDoc(settingsDocRef, userSettings, { merge: true });
                console.log("User settings saved:", userSettings);
            } catch (error) {
                console.error("Error saving user settings:", error);
            }
        }

        // --- Custom Notification Modal Elements (moved to global scope) ---
        const customNotificationModal = document.getElementById('customNotificationModal');
        const customNotificationMessage = document.getElementById('customNotificationMessage');
        const dynamicNotificationToggleContainer = document.getElementById('dynamicNotificationToggleContainer');
        // We'll dynamically create/manage the OK/Cancel buttons within showCustomNotification

        // Function to show custom notification (moved to global scope)
        function showCustomNotification(message, notificationType, confirmCallback = null, showConfirmButtons = false) {
            let currentSettingKey;
            let showToggleInNotification = true; // Flag to decide if the toggle should appear in the notification dialog itself

            // Determine which setting controls this notification's visibility
            if (notificationType === 'recipeCreation') {
                currentSettingKey = 'confirmRecipeCreation';
            } else if (notificationType === 'foodAddition') {
                currentSettingKey = 'confirmFoodAddition';
            } else if (notificationType === 'confirmDeleteRecipe') {
                currentSettingKey = 'confirmDeleteRecipe';
            } else if (notificationType === 'confirmDeleteRecipeItem') { // NEW
                currentSettingKey = 'confirmDeleteRecipeItem';
            } else if (notificationType === 'confirmSaveChanges') { // NEW
                currentSettingKey = 'confirmSaveChanges';
            } else if (notificationType === 'recipeSaveSuccess') { // NEW
                currentSettingKey = 'confirmRecipeSaveSuccess';
            } else if (notificationType === 'recipeDeletionSuccess') {
                currentSettingKey = 'confirmRecipeDeletionSuccess'; // New setting
            } else if (notificationType === 'recipeDeletionError') {
                currentSettingKey = 'confirmRecipeDeletionError'; // New setting
            } else {
                // For unknown types, no specific setting, just show the message without a toggle
                showToggleInNotification = false;
            }

            // --- Core Logic: Decide whether to show the modal or execute callback directly ---
            // If there's a specific setting for this notification type, and it's OFF, and it's NOT a confirmation dialog
            // (meaning it's an informational message that the user chose to hide), then skip showing the modal).
            if (currentSettingKey && !userSettings[currentSettingKey] && !showConfirmButtons) {
                console.log(`Notifikace typu '${notificationType}' je vypnuta v nastaven√≠. Proveden√≠ akce p≈ô√≠mo (pokud je callback).`);
                if (confirmCallback) {
                    confirmCallback(); // This would be for cases where a "success" message might trigger a reload, etc.
                }
                return; // Do not show the modal
            }

            // If it's a confirmation dialog and the setting is OFF, execute callback directly.
            // This handles the "skip confirmation" case.
            if ((currentSettingKey === 'confirmDeleteRecipe' || currentSettingKey === 'confirmDeleteRecipeItem' || currentSettingKey === 'confirmSaveChanges') && !userSettings[currentSettingKey] && showConfirmButtons) { // MODIFIED
                console.log(`Potvrzen√≠ je vypnuto. Proveden√≠ akce p≈ô√≠mo.`);
                if (confirmCallback) {
                    confirmCallback();
                }
                return;
            }

            customNotificationMessage.innerHTML = message;
            customNotificationModal.style.display = 'flex';

            dynamicNotificationToggleContainer.innerHTML = ''; // Clear previous content
            const notificationControls = customNotificationModal.querySelector('.notification-controls');
            notificationControls.innerHTML = ''; // Clear existing buttons

            // Add toggle if applicable and if it's supposed to be shown in the notification dialog
            if (showToggleInNotification && currentSettingKey) {
                const toggleLabelWrapper = document.createElement('label');
                // Apply specific classes for notification toggles
                toggleLabelWrapper.classList.add('toggle-switch', 'notification-toggle-switch');

                const toggleInput = document.createElement('input');
                toggleInput.type = 'checkbox';
                toggleInput.checked = userSettings[currentSettingKey];
                toggleInput.id = `dynamicToggle-${notificationType}`;

                const sliderSpan = document.createElement('span');
                sliderSpan.classList.add('slider');

                toggleLabelWrapper.appendChild(toggleInput);
                toggleLabelWrapper.appendChild(sliderSpan);

                const labelElement = document.createElement('span');
                // Apply specific classes for notification labels
                labelElement.classList.add('toggle-label', 'notification-toggle-label');
                labelElement.textContent = 'Zobrazovat tento dialog';

                // Always put toggle first for all notifications now
                dynamicNotificationToggleContainer.appendChild(toggleLabelWrapper); // Toggle first
                dynamicNotificationToggleContainer.appendChild(labelElement); // Then label

                toggleInput.addEventListener('change', () => {
                    userSettings[currentSettingKey] = toggleInput.checked;
                    saveUserSettings();
                    // Update the main settings modal toggle if it exists and matches
                    const settingsToggle = document.getElementById(`${currentSettingKey}Toggle`);
                    if (settingsToggle) {
                        settingsToggle.checked = toggleInput.checked;
                    }
                    console.log(`Nastaven√≠ '${currentSettingKey}' zmƒõnƒõno na: ${toggleInput.checked}`);
                });
            }

            // Create a wrapper for buttons to ensure consistent flex behavior
            const buttonsContainer = document.createElement('div');
            buttonsContainer.style.display = 'flex';
            buttonsContainer.style.gap = '10px'; // Space between buttons
            buttonsContainer.style.alignItems = 'flex-end'; // Align buttons to their own bottom

            if (showConfirmButtons) {
                const noButton = document.createElement('button');
                noButton.textContent = 'Ne';
                noButton.classList.add('notification-button');
                noButton.style.backgroundColor = '#f44336';
                noButton.onmouseover = () => noButton.style.backgroundColor = '#d32f2f';
                noButton.onmouseout = () => noButton.style.backgroundColor = '#f44336';
                noButton.onclick = () => {
                    customNotificationModal.style.display = 'none';
                };
                buttonsContainer.appendChild(noButton);

                const yesButton = document.createElement('button');
                yesButton.textContent = 'Ano';
                yesButton.classList.add('notification-button');
                yesButton.style.backgroundColor = '#4CAF50';
                yesButton.onmouseover = () => yesButton.style.backgroundColor = '#45a049';
                yesButton.onmouseout = () => yesButton.style.backgroundColor = '#4CAF50';
                yesButton.onclick = () => {
                    customNotificationModal.style.display = 'none';
                    if (confirmCallback) {
                        confirmCallback();
                    }
                };
                buttonsContainer.appendChild(yesButton);

            } else {
                const okButton = document.createElement('button');
                okButton.textContent = 'OK';
                okButton.classList.add('notification-button');
                okButton.style.backgroundColor = '#4CAF50';
                okButton.onclick = () => { customNotificationModal.style.display = 'none'; };
                buttonsContainer.appendChild(okButton);
            }

            // Append elements to notificationControls
            if (dynamicNotificationToggleContainer.children.length > 0) {
                notificationControls.appendChild(dynamicNotificationToggleContainer);
            }
            notificationControls.appendChild(buttonsContainer);

            // Apply consistent styles to notificationControls
            notificationControls.style.display = 'flex';
            notificationControls.style.justifyContent = 'space-between'; // Push toggle left, buttons right
            notificationControls.style.alignItems = 'flex-end'; // Align both to the bottom
            notificationControls.style.flexWrap = 'nowrap';
            notificationControls.style.gap = '10px';
            notificationControls.style.paddingTop = '15px';
            notificationControls.style.borderTop = '1px solid #eee'; // Corrected line
        }

        // --- Firestore Functions (moved to global scope) ---
        async function createNewRecipe(recipeName, foodItem) {
            if (!db || !userId) {
                console.error("Firestore or User ID not initialized.");
                return;
            }
            try {
                const recipesColRef = collection(db, `artifacts/${appId}/users/${userId}/recipes`);
                const newRecipeDoc = await addDoc(recipesColRef, {
                    name: recipeName,
                    userId: userId,
                    ingredients: foodItem ? [foodItem] : [], // Add the initial food item if provided
                    createdAt: serverTimestamp(),
                    updatedAt: serverTimestamp()
                });
                console.log("New recipe created with ID:", newRecipeDoc.id);
                // Updated message with bold formatting
                showCustomNotification(`Recept "<strong>${recipeName}</strong>" byl vytvo≈ôen a byla do nƒõj vlo≈æena polo≈æka "<strong>${foodItem.foodName}</strong>"!`, 'recipeCreation');
                return newRecipeDoc.id;
            } catch (error) {
                console.error("Error creating new recipe:", error);
                showCustomNotification("Chyba p≈ôi vytv√°≈ôen√≠ nov√©ho receptu: " + error.message, 'recipeCreation');
                return null;
            }
        }

        async function addFoodItemToExistingRecipe(recipeId, foodItem) {
            if (!db || !userId) {
                console.error("Firestore or User ID not initialized.");
                return;
            }
            try {
                const recipeDocRef = doc(db, `artifacts/${appId}/users/${userId}/recipes`, recipeId);
                const recipeSnap = await getDoc(recipeDocRef);

                if (recipeSnap.exists()) {
                    const currentIngredients = recipeSnap.data().ingredients || [];
                    const updatedIngredients = [...currentIngredients, foodItem];
                    await updateDoc(recipeDocRef, {
                        ingredients: updatedIngredients,
                        updatedAt: serverTimestamp()
                    });
                    console.log(`Food item added to recipe ${recipeId}`);
                    // Updated message with bold formatting
                    showCustomNotification(`Polo≈æka "<strong>${foodItem.foodName}</strong>" byla p≈ôid√°na do receptu "<strong>${recipeSnap.data().name}</strong>"!`, 'foodAddition');
                } else {
                    console.error("Recipe not found:", recipeId);
                    showCustomNotification("Vybran√Ω recept nebyl nalezen.", 'foodAddition');
                }
            } catch (error) {
                console.error("Error adding food item to recipe:", error);
                showCustomNotification("Chyba p≈ôi p≈ôid√°v√°n√≠ polo≈æky do receptu: " + error.message, 'foodAddition');
            }
        }

        async function updateFoodItemInRecipe(recipeId, ingredientIndex, updatedFoodItem) {
            if (!db || !userId) {
                console.error("Firestore or User ID not initialized.");
                return;
            }

            // Declare recipeDocRef at the top of the function
            const recipeDocRef = doc(db, `artifacts/${appId}/users/${userId}/recipes`, recipeId);

            const executeUpdate = async () => { // Wrap the core update logic in a function
                try {
                    const recipeSnap = await getDoc(recipeDocRef);

                    if (recipeSnap.exists()) {
                        const currentIngredients = recipeSnap.data().ingredients || [];
                        if (ingredientIndex >= 0 && ingredientIndex < currentIngredients.length) {
                            currentIngredients[ingredientIndex] = updatedFoodItem;
                            await updateDoc(recipeDocRef, {
                                ingredients: currentIngredients,
                                updatedAt: serverTimestamp()
                            });
                            console.log(`Food item at index ${ingredientIndex} updated in recipe ${recipeId}`);

                            // Close the details modal (editing view)
                            detailsModal.style.display = 'none';

                            // Fetch the updated recipe name from the current snap or refetch if needed
                            const updatedRecipeName = recipeSnap.data().name;
                            await showRecipeDetailsModal(recipeId, updatedRecipeName); // Reload recipe details

                            // Show success notification after successful update and reload
                            showCustomNotification(`Polo≈æka "<strong>${updatedFoodItem.foodName}</strong>" v receptu byla √∫spƒõ≈°nƒõ aktualizov√°na.`, 'recipeSaveSuccess');

                        } else {
                            console.error("Ingredient index out of bounds:", ingredientIndex);
                            showCustomNotification("Chyba: Index polo≈æky mimo rozsah.", 'recipeDeletionError'); // Reusing error type
                        }
                    } else {
                        console.error("Recipe not found:", recipeId);
                        showCustomNotification("Vybran√Ω recept nebyl nalezen.", 'recipeDeletionError'); // Reusing error type
                    }
                } catch (error) {
                    console.error("Error updating food item in recipe:", error);
                    showCustomNotification("Chyba p≈ôi aktualizaci polo≈æky v receptu: " + error.message, 'recipeDeletionError'); // Reusing error type
                }
            };

            // Call the confirmation dialog
            showCustomNotification(`Opravdu chcete ulo≈æit zmƒõny pro polo≈æku "<strong>${updatedFoodItem.foodName}</strong>"?`, 'confirmSaveChanges', executeUpdate, true);
        }

        async function deleteRecipe(recipeId, recipeName) {
            if (!db || !userId) {
                console.error("Firestore or User ID not initialized.");
                return;
            }
            // Add a confirmation step before deleting
            // The third argument is a callback for 'confirm' action, and the fourth indicates if it's a confirmation type
            showCustomNotification(`Opravdu chcete odstranit recept "<strong>${recipeName}</strong>"?`, 'confirmDeleteRecipe', async () => {
                try {
                    const recipeDocRef = doc(db, `artifacts/${appId}/users/${userId}/recipes`, recipeId);
                    await deleteDoc(recipeDocRef);
                    console.log(`Recipe ${recipeId} deleted.`);
                    showCustomNotification(`Recept "<strong>${recipeName}</strong>" byl √∫spƒõ≈°nƒõ smaz√°n.`, 'recipeDeletionSuccess');
                    loadUserRecipes(); // Reload the list after deletion
                } catch (error) {
                    console.error("Error deleting recipe:", error);
                    showCustomNotification(`Chyba p≈ôi odstra≈àov√°n√≠ receptu "<strong>${recipeName}</strong>": ${error.message}`, 'recipeDeletionError');
                }
            }, true); // Pass true to indicate this notification needs a confirm button
        }

        // NEW: Function to delete a food item from a recipe
        async function deleteFoodItemFromRecipe(recipeId, ingredientIndex, ingredientName, recipeName) {
            if (!db || !userId) {
                console.error("Firestore or User ID not initialized.");
                return;
            }
            showCustomNotification(`Opravdu chcete odstranit polo≈æku "<strong>${ingredientName}</strong>" z receptu "<strong>${recipeName}</strong>"?`, 'confirmDeleteRecipeItem', async () => {
                try {
                    const recipeDocRef = doc(db, `artifacts/${appId}/users/${userId}/recipes`, recipeId);
                    const recipeSnap = await getDoc(recipeDocRef);

                    if (recipeSnap.exists()) {
                        const currentIngredients = recipeSnap.data().ingredients || [];
                        if (ingredientIndex >= 0 && ingredientIndex < currentIngredients.length) {
                            currentIngredients.splice(ingredientIndex, 1); // Remove the ingredient
                            await updateDoc(recipeDocRef, {
                                ingredients: currentIngredients,
                                updatedAt: serverTimestamp()
                            });
                            console.log(`Ingredient at index ${ingredientIndex} deleted from recipe ${recipeId}.`);
                            showCustomNotification(`Polo≈æka "<strong>${ingredientName}</strong>" byla √∫spƒõ≈°nƒõ smaz√°na z receptu "<strong>${recipeName}</strong>".`, 'recipeDeletionSuccess');
                            // Reload the recipe details modal to reflect the change
                            await showRecipeDetailsModal(recipeId, recipeName);
                        } else {
                            console.error("Ingredient index out of bounds:", ingredientIndex);
                            showCustomNotification("Chyba: Index polo≈æky mimo rozsah.", 'recipeDeletionError');
                        }
                    } else {
                        console.error("Recipe not found:", recipeId);
                        showCustomNotification("Vybran√Ω recept nebyl nalezen.", 'recipeDeletionError');
                    }
                } catch (error) {
                    console.error("Error deleting food item from recipe:", error);
                    showCustomNotification(`Chyba p≈ôi odstra≈àov√°n√≠ polo≈æky "<strong>${ingredientName}</strong>": ${error.message}`, 'recipeDeletionError');
                }
            }, true); // Pass true to indicate this notification needs a confirm button
        }

        async function loadUserRecipes(forAdding = false) {
            if (!db || !userId) {
                console.error("Firestore or User ID not initialized.");
                existingRecipesList.innerHTML = '<li class="no-recipes-message">Chyba: Aplikace se nenaƒçetla spr√°vnƒõ.</li>';
                return;
            }
            existingRecipesList.innerHTML = '<li class="no-recipes-message">Naƒç√≠t√°m recepty...</li>';
            const recipeCountDisplay = document.getElementById('recipeCountDisplay'); // Get the new element
            recipeCountDisplay.textContent = ''; // Clear previous count

            try {
                // Order by 'createdAt' in descending order for newest first
                const q = query(collection(db, `artifacts/${appId}/users/${userId}/recipes`), orderBy('createdAt', 'desc'));
                const querySnapshot = await getDocs(q);

                existingRecipesList.innerHTML = ''; // Clear previous list

                if (querySnapshot.empty) {
                    existingRecipesList.innerHTML = '<li class="no-recipes-message">≈Ω√°dn√© recepty nenalezeny.</li>';
                    recipeCountDisplay.textContent = 'Celkem recept≈Ø: 0'; // Update count
                } else {
                    let recipeCounter = 1; // Initialize counter
                    querySnapshot.forEach((doc) => {
                        const recipe = doc.data();
                        const listItem = document.createElement('li');
                        listItem.classList.add('recipe-list-item'); // Add a class for styling
                        listItem.dataset.recipeId = doc.id; // Store recipe ID

                        // Create a span for the recipe name, including the number
                        const recipeNameSpan = document.createElement('span');
                        recipeNameSpan.textContent = `${recipeCounter}. ${recipe.name}`; // Add numbering
                        listItem.appendChild(recipeNameSpan);

                        // Create a container for icons
                        const iconContainer = document.createElement('div');
                        iconContainer.classList.add('recipe-icons');

                        // Delete icon
                        const deleteIcon = document.createElement('img');
                        deleteIcon.src = "{{ url_for('static', filename='icon/kos.png') }}";
                        deleteIcon.alt = "Odstranit";
                        deleteIcon.classList.add('recipe-icon');
                        deleteIcon.addEventListener('click', (e) => {
                            e.stopPropagation(); // Prevent listItem click
                            deleteRecipe(doc.id, recipe.name); // Call delete function
                        });
                        iconContainer.appendChild(deleteIcon);

                        listItem.appendChild(iconContainer);

                        // If this list is for adding food, make the list item itself clickable
                        if (forAdding) {
                            listItem.classList.add('clickable-recipe-item'); // Add a class to indicate clickability
                            listItem.addEventListener('click', async () => {
                                await addFoodItemToExistingRecipe(doc.id, currentFoodItemData);
                                selectRecipeModal.style.display = 'none'; // Close selection modal
                            });
                        } else { // This is for viewing recipe details
                            listItem.classList.add('clickable-recipe-item'); // Ensure it's clickable for viewing
                            listItem.addEventListener('click', async () => {
                                selectRecipeModal.style.display = 'none'; // Close the recipe list modal
                                await showRecipeDetailsModal(doc.id, recipe.name); // Show recipe details
                            });
                        }

                        existingRecipesList.appendChild(listItem);
                        recipeCounter++; // Increment counter
                    });
                    recipeCountDisplay.textContent = `Celkem recept≈Ø: ${querySnapshot.size}`; // Update total count
                }
            } catch (error) {
                console.error("Error loading user recipes:", error);
                existingRecipesList.innerHTML = '<li class="no-recipes-message">Chyba p≈ôi naƒç√≠t√°n√≠ recept≈Ø.</li>';
                recipeCountDisplay.textContent = 'Celkem recept≈Ø: Chyba'; // Update count on error
                showCustomNotification("Chyba p≈ôi naƒç√≠t√°n√≠ recept≈Ø: " + error.message, 'foodAddition');
            }
        }

        // New function to show recipe details modal
        async function showRecipeDetailsModal(recipeId, recipeName) {
            console.log("showRecipeDetailsModal called for recipe ID:", recipeId, "name:", recipeName);
            modalDetailsContent.classList.add('modal-recipe-container');
            document.getElementById('modalDetailsContent').classList.add('modal-recipe-container');
            detailsModal.style.display = 'flex';
            modalDetailsContent.innerHTML = `<p class="loading-details">Naƒç√≠t√°m detaily receptu "${recipeName}"...</p>`;

            if (!db || !userId) {
                modalDetailsContent.innerHTML = `<p class="error-details">Chyba: Aplikace se nenaƒçetla spr√°vnƒõ. Nelze naƒç√≠st recept.</p>`;
                return;
            }

            try {
                const recipeDocRef = doc(db, `artifacts/${appId}/users/${userId}/recipes`, recipeId);
                const recipeSnap = await getDoc(recipeDocRef);

                if (!recipeSnap.exists()) {
                    modalDetailsContent.innerHTML = `<p class="error-details">Recept "${recipeName}" nebyl nalezen.</p>`;
                    return;
                }

                const recipeData = recipeSnap.data();
                const imageUrl = recipeData.imageUrl || "{{ url_for('static', filename='icon/recepty.png') }}";
                const ingredients = recipeData.ingredients || [];

                // Agregace nutrient≈Ø
                const aggregatedNutrients = {
                    total_kcal: 0, total_kj: 0, protein: 0, carbs: 0, sugar: 0, fat: 0,
                    saturated_fat: 0, trans_fat: 0, monounsaturated_fat: 0, polyunsaturated_fat: 0,
                    cholesterol: 0, fiber: 0, salt: 0, calcium: 0, sodium: 0, water: 0, phe: 0
                };

                ingredients.forEach(ingredient => {
                    if (ingredient.nutritionalDetails && typeof ingredient.nutritionalDetails === 'object') {
                        const amount = parseFloat(ingredient.amount) || 0;
                        let baseAmount = amount;
                        if (ingredient.unit === 'kg' || ingredient.unit === 'l') baseAmount *= 1000;
                        const factor = baseAmount / 100;
                        
                        for (const key in aggregatedNutrients) {
                            if (ingredient.nutritionalDetails[key] && ingredient.nutritionalDetails[key] !== "N/A") {
                                const { number: valNum } = parseValueAndUnit(ingredient.nutritionalDetails[key]);
                                if (!isNaN(valNum)) aggregatedNutrients[key] += valNum * factor;
                            }
                        }
                    }
                });

                const totalKj = aggregatedNutrients.total_kj || (aggregatedNutrients.total_kcal * 4.184);
                const formattedAggregatedNutrients = {};
                for (const key in aggregatedNutrients) {
                    let unit = '';
                    if (key.includes('kcal')) unit = 'kcal';
                    else if (key.includes('kj')) unit = 'kJ';
                    else if (['protein','carbs','sugar','fat','saturated_fat','trans_fat',
                             'monounsaturated_fat','polyunsaturated_fat','fiber','salt','water','phe'].includes(key)) unit = 'g';
                    else if (['cholesterol','calcium','sodium'].includes(key)) unit = 'mg';
                    
                    formattedAggregatedNutrients[key] = formatNumberForDisplay(aggregatedNutrients[key], unit, key.includes('kcal') || key.includes('kj'));
                }

                let recipeDetailsHtml = `
            <div class="modal-recipe-header">
                <img
                    id="modalHeaderImage"
                    src="${imageUrl}"
                    alt="${recipeName}"
                    class="modal-header-image"
                    onerror="this.onerror=null;this.src='{{ url_for('static', filename='icon/recepty.png') }}'"
                />
                <div class="modal-header-text">
                    <div id="modalHeaderName" class="modal-header-name">${recipeName}</div>
                    <div class="energy-display-group">
                        <div id="totalKcalDisplay" class="energy-header">${formattedAggregatedNutrients.total_kcal}</div>
                        <div id="totalKjDisplay" class="energy-sub-header">${formatNumberForDisplay(totalKj, 'kJ', true)}</div>
                    </div>
                </div>
            </div>

            <div class="modal-scrollable-container">
                <div id="nutrientDetailsSection"></div>
                <h3 class="ingredients-title">Slo≈æen√≠ receptu:</h3>
                <div id="recipeIngredientsList"></div>
            </div>
        `;

                modalDetailsContent.innerHTML = recipeDetailsHtml;

                
                // Render nutrient≈Ø
                renderAllNutrientDetails(formattedAggregatedNutrients);

                // Render ingredienc√≠
                const ingredientsListEl = document.getElementById('recipeIngredientsList');
                if (ingredients.length === 0) {
                    ingredientsListEl.innerHTML = '<p style="text-align: center; color: #888;">Tento recept neobsahuje ≈æ√°dn√© potraviny.</p>';
                } else {
                    ingredients.forEach((ingredient, index) => {
                        const ingredientItemDiv = document.createElement('div');
                        ingredientItemDiv.classList.add('food-item', 'food-item-potravina');
                        const ingPlaceholderImage = "{{ url_for('static', filename='icon/potraviny.png') }}";
                        let displayImageUrl = ingredient.imageUrl || ingPlaceholderImage;
                        const { number: kcalNum, unit: kcalUnit } = parseValueAndUnit(ingredient.kcal);
                        const formattedIngredientKcal = formatNumberForDisplay(kcalNum, kcalUnit, true);

                        ingredientItemDiv.innerHTML = `
                            <div class="image-wrapper" style="display: flex; flex-direction: column; align-items: center;">
                                <img src="${displayImageUrl}" alt="${ingredient.foodName}" onerror="this.onerror=null;this.src='${ingPlaceholderImage}'" />
                                <div class="recipe-icons" style="margin-top: 5px;">
                                    <img src="{{ url_for('static', filename='icon/editace.png') }}" alt="Upravit" class="recipe-icon edit-icon" data-recipe-id="${recipeId}" data-ingredient-index="${index}" />
                                    <img src="{{ url_for('static', filename='icon/kos.png') }}" alt="Odstranit" class="recipe-icon delete-icon" data-recipe-id="${recipeId}" data-ingredient-index="${index}" />
                                </div>
                            </div>
                            <div class="food-details">
                                <h3>${ingredient.foodName}</h3>
                                <div class="calories-and-type-row">
                                    <div class="calories-and-type-row">
                                        <span class="amount-display">Mno≈æstv√≠:  ${ingredient.amount} ${ingredient.unit}</span>
                                        <span class="calories-display">Kalorie: ${formattedIngredientKcal}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                        ingredientsListEl.appendChild(ingredientItemDiv);

                        // Edit ikonka
                        const editIcon = ingredientItemDiv.querySelector('.edit-icon');
                        if (editIcon) {
                            editIcon.addEventListener('click', async (e) => {
                                e.stopPropagation();
                                currentEditingRecipeId = e.target.dataset.recipeId;
                                currentEditingIngredientIndex = parseInt(e.target.dataset.ingredientIndex);
                                const ingredientToEdit = ingredients[currentEditingIngredientIndex];
                                if (ingredientToEdit) {
                                    await showDetailsModal(
                                        ingredientToEdit.slug,
                                        ingredientToEdit.foodName,
                                        ingredientToEdit.imageUrl,
                                        ingredientToEdit.kcal,
                                        ingredientToEdit.foodType,
                                        true,
                                        ingredientToEdit.amount,
                                        ingredientToEdit.unit,
                                        ingredientToEdit.nutritionalDetails
                                    );
                                } else {
                                    console.error("Ingredient not found at index:", currentEditingIngredientIndex);
                                    showCustomNotification("Chyba: Polo≈æka receptu k √∫pravƒõ nebyla nalezena.", 'info');
                                }
                            });
                        }

                        // Delete ikonka
                        const deleteIcon = ingredientItemDiv.querySelector('.delete-icon');
                        if (deleteIcon) {
                            deleteIcon.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const currentRecipeId = e.target.dataset.recipeId;
                                const ingredientIndex = parseInt(e.target.dataset.ingredientIndex);
                                const ingredientName = ingredient.foodName;
                                deleteFoodItemFromRecipe(currentRecipeId, ingredientIndex, ingredientName, recipeName);
                            });
                        }
                    });
                }

                // Dynamick√° velikost n√°zvu v hlaviƒçce
                const modalHeaderImage = document.getElementById('modalHeaderImage');
                const modalHeaderName = document.getElementById('modalHeaderName');
                if (modalHeaderImage && modalHeaderName) {
                    const imageHeight = modalHeaderImage.offsetHeight;
                    let currentFontSize = imageHeight * 0.25;
                    modalHeaderName.style.fontSize = `${currentFontSize}px`;

                    while ((modalHeaderName.scrollWidth > modalHeaderName.clientWidth || modalHeaderName.scrollHeight > modalHeaderName.clientHeight) && currentFontSize > 10) {
                        currentFontSize -= 0.5;
                        modalHeaderName.style.fontSize = `${currentFontSize}px`;
                    }
                }

            } catch (error) {
                console.error("Error loading recipe details:", error);
                modalDetailsContent.innerHTML = `<p class="error-details">Do≈°lo k chybƒõ p≈ôi naƒç√≠t√°n√≠ detail≈Ø receptu: ${error.message}</p>`;
            }
        }

// --- Barcode Scanner Functions ---
let barcodeModal = null;
let barcodeVideo = null;
let barcodeCanvas = null;
let barcodeOverlay = null;
let barcodeStatus = null;
let stream = null;
let currentDeviceId = null;
let facingMode = 'environment';
let flashEnabled = false;
let scanInterval = null;
let quaggaInitialized = false;

function debugCameraStream() {
    if (barcodeVideo && barcodeVideo.srcObject) {
        console.log('Video dimensions:', barcodeVideo.videoWidth, 'x', barcodeVideo.videoHeight);
        console.log('Video ready state:', barcodeVideo.readyState);
        console.log('Stream active:', barcodeVideo.srcObject.active);
        
        const tracks = barcodeVideo.srcObject.getVideoTracks();
        if (tracks.length > 0) {
            console.log('Track settings:', tracks[0].getSettings());
        }
    }
}

// Inicializace skeneru ƒç√°rov√Ωch k√≥d≈Ø
function initBarcodeScanner() {
    barcodeModal = document.getElementById('barcodeModal');
    barcodeVideo = document.getElementById('barcodeVideo');
    barcodeCanvas = document.getElementById('barcodeCanvas');
    barcodeOverlay = document.getElementById('barcodeOverlay');
    barcodeStatus = document.getElementById('barcodeStatus');
    
    // Event listenery pro mod√°ln√≠ okno skeneru
    document.getElementById('closeBarcodeModal').addEventListener('click', closeBarcodeScanner);
    document.getElementById('toggleCameraButton').addEventListener('click', toggleCamera);
    document.getElementById('toggleFlashButton').addEventListener('click', toggleFlash);
    document.getElementById('submitManualBarcode').addEventListener('click', submitManualBarcode);
    
    // P≈òIDEJTE TOTO - event listener pro nov√© tlaƒç√≠tko
    document.getElementById('stopScanButton').addEventListener('click', stopBarcodeScanning);

    // Event listener pro tlaƒç√≠tko skeneru
    document.getElementById('barcodeButton').addEventListener('click', openBarcodeScanner);
    
    // Inicializace QuaggaJS
    initQuagga();
}

function stopBarcodeScanning() {
    // Zastav√≠me skenov√°n√≠
    if (quaggaInitialized) {
        Quagga.stop();
    }
    
    if (scanInterval) {
        clearInterval(scanInterval);
        scanInterval = null;
    }
    
    // Skryjeme tlaƒç√≠tko "Zastavit"
    document.getElementById('stopScanButton').style.display = 'none';
    
    // Zmƒõn√≠me status
    barcodeStatus.textContent = 'Skenov√°n√≠ zastaveno';
    barcodeStatus.style.color = '#666';
}

// Inicializace QuaggaJS
function initQuagga() {
    if (typeof Quagga !== 'undefined') {
        try {
            Quagga.init({
                inputStream: {
                    name: "Live",
                    type: "LiveStream",
                    target: barcodeVideo,
                    constraints: {
                        width: 1280,
                        height: 720,
                        facingMode: facingMode,
                        aspectRatio: { ideal: 16/9 }
                    },
                },
                decoder: {
                    readers: [
                        "ean_reader",
                        "ean_8_reader",
                        "upc_reader",
                        "upc_e_reader"
                    ],
                    debug: {
                        drawBoundingBox: false,
                        showPattern: false,
                        showFoundPattern: false,
                        //showSkeleton: true,
                        //showLabels: true,
                        //showPatch: true,
                        //showRecalculated: true
                    }
                },
                locator: {
                    patchSize: "medium",
                    halfSample: true
                },
                preprocessor: {
                // Zv√Ω≈°√≠ kontrast pro lep≈°√≠ ƒçitelnost
                    contrast: {
                    min: 32,
                    max: 220
                    },
                    // Zv√Ω≈°√≠ ostrost
                    sharpen: {
                    flat: 1.0,
                    jagged: 2.0
                    }
                },
                frequency: 10,
                numOfWorkers: 5,
                debug: false // Vypnout debug pro lep≈°√≠ v√Ωkon
                }, function(err) {
                if (err) {
                    console.error("Chyba p≈ôi inicializaci Quagga:", err);
                    barcodeStatus.textContent = 'Nepoda≈ôilo se inicializovat skener';
                    barcodeStatus.style.color = 'red';
                    // POKUS O OBNOVU PO CHYBƒö
                    setTimeout(() => {
                        if (barcodeModal.style.display === 'flex') {
                            console.log('Zkou≈°√≠m znovu inicializovat Quaggu...');
                            initQuagga();
                        }
                    }, 1000);
                    return;
                }
                
                quaggaInitialized = true;
                console.log("Quagga inicializov√°na");
                
                Quagga.onDetected(function(result) {
                    console.log('Quagga result:', result);
        
                    if (result && result.codeResult && result.codeResult.code) {
                        console.log('Detekov√°n k√≥d:', result.codeResult.code, 
                                   'typ:', result.codeResult.format,
                                   'confidence:', result.codeResult.confidence);
            
                        // P≈ôidejte v√≠ce debug info
                        if (result.codeResult.decoded) {
                           console.log('Decoded info:', result.codeResult.decoded);
                        }
            
                        // Filtr podle confidence pokud je dostupn√°
                        if (result.codeResult.confidence !== undefined && 
                            result.codeResult.confidence < 0.3) {
                            console.log('P≈ô√≠li≈° n√≠zk√° confidence, ignoruji:', result.codeResult.confidence);
                            return;
                        }
            
                        handleBarcodeDetected(result.codeResult.code);
                    }
                });
            });
        } catch (error) {
            console.error('V√Ωjimka p≈ôi inicializaci Quaggy:', error);
        }
    }
}

// Fallback funkce pro canvas detection
function startCanvasFallback() {
    barcodeStatus.textContent = 'Pou≈æ√≠v√°m z√°kladn√≠ detekci...';
    barcodeStatus.style.color = 'orange';
    
    scanInterval = setInterval(async () => {
        if (barcodeVideo.readyState === barcodeVideo.HAVE_ENOUGH_DATA) {
            try {
                const barcodes = await detectBarcodesWithCanvas();
                if (barcodes.length > 0) {
                    handleBarcodeDetected(barcodes[0]);
                }
            } catch (error) {
                console.error('Chyba p≈ôi detekci ƒç√°rov√©ho k√≥du:', error);
            }
        }
    }, 1000);
}

// Odesl√°n√≠ ruƒçnƒõ zadan√©ho ƒç√°rov√©ho k√≥du
function submitManualBarcode() {
    const manualBarcodeInput = document.getElementById('manualBarcodeInput');
    const barcode = manualBarcodeInput.value.trim();
    
    if (barcode) {
        closeBarcodeScanner();
        searchByBarcode(barcode);
    } else {
        barcodeStatus.textContent = 'Pros√≠m, zadejte ƒç√°rov√Ω k√≥d';
        barcodeStatus.style.color = 'red';
    }
}


// Otev≈ôen√≠ skeneru ƒç√°rov√Ωch k√≥d≈Ø
async function openBarcodeScanner() {
    console.log('Otev√≠r√°m skener...');
    barcodeModal.style.display = 'flex';
    barcodeStatus.textContent = 'Inicializace...';
    barcodeStatus.innerHTML = `
        <div>Skenov√°n√≠ spu≈°tƒõno</div>
        <div class="scanning-tip">Nami≈ôte na ƒç√°rov√Ω k√≥d ve dobr√©m osvƒõtlen√≠</div>
        <div class="scanning-loading">üîç Skenuji...</div>
    `;   
    
    // ZOBRAZ√çME TLAƒå√çTKO "ZASTAVIT"
    document.getElementById('stopScanButton').style.display = 'block';
    
    // Zkontrolujeme, zda je API dostupn√©
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        barcodeStatus.textContent = 'Kamera nen√≠ v tomto prohl√≠≈æeƒçi dostupn√°';
        barcodeStatus.style.color = 'red';
        return;
    }

    try {
        await startCamera();
        debugCameraStream();
        barcodeStatus.textContent = 'Nami≈ôte na ƒç√°rov√Ω k√≥d';
        
        // POƒåK√ÅME, NE≈Ω SE VIDEO NAƒåTE
        await new Promise(resolve => setTimeout(resolve, 500));
        
        startBarcodeScanning();
    } catch (error) {
        console.error('Chyba p≈ôi inicializaci kamery:', error);
        barcodeStatus.textContent = 'Chyba: ' + error.message;
        barcodeStatus.style.color = 'red';
        
        // POKUS O OBNOVU QUAGGY
        if (quaggaInitialized) {
            try {
                Quagga.stop();
                // Poƒçk√°me a zkus√≠me znovu
                setTimeout(() => {
                    if (barcodeModal.style.display === 'flex') {
                        startBarcodeScanning();
                    }
                }, 1000);
            } catch (e) {
                console.error('Nelze obnovit Quaggu:', e);
            }
        }
    }
}

function restartQuagga() {
    console.log('Restartuji Quaggu...');
    
    if (typeof Quagga !== 'undefined') {
        try {
            // Zastav√≠me souƒçasnou instanci
            if (quaggaInitialized) {
                Quagga.stop();
                Quagga.offDetected();
                Quagga.offProcessed();
            }
            
            // Resetujeme stav
            quaggaInitialized = false;
            lastDetectedBarcode = null;
            
            // Poƒçk√°me chv√≠li
            setTimeout(() => {
                initQuagga();
                console.log('Quagga restartov√°na');
            }, 500);
            
        } catch (error) {
            console.error('Chyba p≈ôi restartu Quaggy:', error);
        }
    }
}

// Spu≈°tƒõn√≠ kamery
async function startCamera() {
    // Zastav√≠me existuj√≠c√≠ stream
    if (stream) {
        stream.getTracks().forEach(track => track.stop());
    }
    
    const constraints = {
    video: {
        facingMode: facingMode,
        width: { ideal: 1280 }, // Zv√Ω≈°en√≠ rozli≈°en√≠
        height: { ideal: 720 },
        frameRate: { ideal: 30 },
        // P≈ôidejte po≈æadavek na autofocus
        advanced: [{ focusMode: "continuous" }, { focusDistance: { ideal: 0.2 } }]
    }
    };
    
    // Pokud m√°me ulo≈æen√© deviceId, pou≈æijeme ho
    if (currentDeviceId) {
        constraints.video.deviceId = { exact: currentDeviceId };
    }
    
    try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        barcodeVideo.srcObject = stream;
        barcodeVideo.style.display = 'block';
        document.getElementById('barcodeUnsupportedMessage').style.display = 'none';
        document.getElementById('toggleCameraButton').style.display = 'inline-block';
        document.getElementById('toggleFlashButton').style.display = 'inline-block';
        barcodeOverlay.style.display = 'block';
        
        // Explicitnƒõ nastavte velikost videa pro Quagga
        barcodeVideo.width = 640;
        barcodeVideo.height = 480;
        
        // Ulo≈æ√≠me deviceId pro p≈ô√≠≈°tƒõ
        const videoTrack = stream.getVideoTracks()[0];
        if (videoTrack) {
            currentDeviceId = videoTrack.getSettings().deviceId;
        }
        
        // ƒåek√°me na naƒçten√≠ videa
        return new Promise((resolve) => {
            barcodeVideo.onloadedmetadata = () => {
                barcodeVideo.play().then(() => {
                    console.log('Video started playing');
                    resolve();
                }).catch(error => {
                    console.error('Error playing video:', error);
                    resolve();
                });
            };
            
            // Fallback timeout
            setTimeout(() => resolve(), 1000);
        });
    } catch (error) {
        console.error('Chyba p≈ôi p≈ô√≠stupu ke kame≈ôe:', error);
        document.getElementById('barcodeUnsupportedMessage').style.display = 'block';
        barcodeVideo.style.display = 'none';
        document.getElementById('toggleCameraButton').style.display = 'none';
        document.getElementById('toggleFlashButton').style.display = 'none';
        barcodeOverlay.style.display = 'none';
        
        barcodeStatus.textContent = 'Pou≈æijte ruƒçn√≠ zad√°n√≠ k√≥du';
        throw error;
    }
}

// Spu≈°tƒõn√≠ skenov√°n√≠ ƒç√°rov√Ωch k√≥d≈Ø
function startBarcodeScanning() {
    console.log('Spou≈°t√≠m skenov√°n√≠...');
    
    // Zastav√≠me existuj√≠c√≠ interval
    if (scanInterval) {
        clearInterval(scanInterval);
        scanInterval = null;
    }
    
    // Nastav√≠me ƒçasov√Ω limit pro skenov√°n√≠ (20 sekund)
    if (detectionTimeout) {
        clearTimeout(detectionTimeout);
    }
    detectionTimeout = setTimeout(() => {
        console.log('ƒåasov√Ω limit skenov√°n√≠ vypr≈°el');
        barcodeStatus.textContent = 'ƒåasov√Ω limit vypr≈°el - zkuste to znovu';
        barcodeStatus.style.color = 'orange';
        restartQuagga();
    }, 20000);
    
    // ZKONTROLUJEME, zda je Quagga p≈ôipravena a video funguje
    if (quaggaInitialized && barcodeVideo && barcodeVideo.srcObject) {
        try {
            Quagga.start();
            barcodeStatus.textContent = 'Skenov√°n√≠ spu≈°tƒõno - nami≈ôte na ƒç√°rov√Ω k√≥d';
            console.log('Quagga √∫spƒõ≈°nƒõ restartov√°na');
        } catch (error) {
            console.error('Chyba p≈ôi startu Quaggy:', error);
            // Fallback na canvas
            startCanvasFallback();
        }
    } else {
        console.log('Quagga nen√≠ inicializov√°na nebo video nefunguje, pou≈æ√≠v√°m fallback');
        // Fallback: pou≈æijeme intervalov√© kontrolov√°n√≠ pomoc√≠ canvasu
        startCanvasFallback();
    }
}


// Detekce ƒç√°rov√Ωch k√≥d≈Ø pomoc√≠ canvasu (fallback)
function detectBarcodesWithCanvas() {
    return new Promise((resolve) => {
        if (!barcodeVideo.videoWidth || !barcodeVideo.videoHeight) {
            resolve([]);
            return;
        }
        
        const context = barcodeCanvas.getContext('2d');
        const width = barcodeVideo.videoWidth;
        const height = barcodeVideo.videoHeight;
        
        // Nastav√≠me velikost canvasu
        barcodeCanvas.width = width;
        barcodeCanvas.height = height;
        
        // Nakresl√≠me aktu√°ln√≠ sn√≠mek videa na canvas
        context.drawImage(barcodeVideo, 0, 0, width, height);
        
        try {
            // Zjednodu≈°en√° detekce - v re√°ln√© aplikaci byste pou≈æili knihovnu
            const imageData = context.getImageData(0, 0, width, height);
            const detectedBarcodes = detectSimpleBarcodes(imageData);
            resolve(detectedBarcodes);
        } catch (error) {
            console.error('Chyba p≈ôi detekci:', error);
            resolve([]);
        }
    });
}

// Jednoduch√° detekce ƒç√°rov√Ωch k√≥d≈Ø (vylep≈°en√°)
function detectSimpleBarcodes(imageData) {
    const data = imageData.data;
    const width = imageData.width;
    const height = imageData.height;
    const barcodes = [];
    
    // Projedeme pouze st≈ôedovou oblast (30% v√Ω≈°ky)
    const startY = Math.floor(height * 0.35);
    const endY = Math.floor(height * 0.65);
    
    for (let y = startY; y <= endY; y += Math.floor(height * 0.05)) {
        let inBar = false;
        let barStart = 0;
        let bars = [];
        let barCount = 0;
        
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            
            const brightness = (r + g + b) / 3;
            const isDark = brightness < 80; // P≈ô√≠snƒõj≈°√≠ threshold
            
            if (isDark && !inBar) {
                inBar = true;
                barStart = x;
                barCount++;
            } else if (!isDark && inBar) {
                inBar = false;
                const barWidth = x - barStart;
                
                // Filtrujeme p≈ô√≠li≈° ≈°irok√©/√∫zk√© pruhy
                if (barWidth > 2 && barWidth < 50) {
                    bars.push({ start: barStart, end: x, width: barWidth });
                }
            }
        }
        
        // EAN k√≥d m√° obvykle 30-60 pruh≈Ø
        if (bars.length > 25 && bars.length < 65) {
            console.log('Nalezen potenci√°ln√≠ ƒç√°rov√Ω k√≥d s', bars.length, 'pruhy');
            
            // Zkus√≠me extrahovat numerickou hodnotu
            const numericPattern = extractNumericPattern(bars);
            if (numericPattern && numericPattern.length >= 8) {
                barcodes.push(numericPattern);
                break; // Na≈°li jsme platn√Ω k√≥d, p≈ôestaneme hledat
            }
        }
    }
    
    return barcodes;
}

function extractNumericPattern(bars) {
    // Jednoduch√° heuristika - v re√°ln√© aplikaci by bylo pot≈ôeba proper dek√≥dov√°n√≠
    const widths = bars.map(bar => bar.width);
    const avgWidth = widths.reduce((a, b) => a + b, 0) / widths.length;
    
    // Bin√°rn√≠ reprezentace podle ≈°√≠≈ôky pruh≈Ø
    let binary = '';
    for (const bar of bars) {
        binary += bar.width > avgWidth ? '1' : '0';
    }
    
    // Zkus√≠me naj√≠t nƒõco, co vypad√° jako EAN (13 nebo 8 ƒç√≠slic)
    if (binary.length >= 95) { // EAN-13 m√° cca 95 modul≈Ø
        return 'PRAVDƒöPODOBNY_EAN_13';
    } else if (binary.length >= 67) { // EAN-8 m√° cca 67 modul≈Ø
        return 'PRAVDƒöPODOBNY_EAN_8';
    }
    
    return null;
}



// P≈ôidejte tuto funkci do sv√©ho k√≥du (nejl√©pe nad handleBarcodeDetected)
function isValidEAN(barcode) {
  // Kontrola d√©lky EAN (8 nebo 13 ƒç√≠slic)
  if (!/^\d{8}$|^\d{13}$/.test(barcode)) {
    return false;
  }
  
  // Kontrola checksumu pomoc√≠ existuj√≠c√≠ funkce validateEANChecksum
  return validateEANChecksum(barcode);
}

let lastDetectedBarcode = null;
let detectionTimeout = null;

// Zpracov√°n√≠ nalezen√©ho ƒç√°rov√©ho k√≥du
function handleBarcodeDetected(barcode) {
  if (lastDetectedBarcode === barcode) {
    console.log('Ignoruji opakovanou detekci stejn√©ho k√≥du:', barcode);
    return;
  }
  
  console.log('Nalezen ƒç√°rov√Ω k√≥d:', barcode);
  
  // Upravte handleBarcodeDetected - p≈ôidejte p≈ôed validac√≠:
    if (commonMisreads[barcode]) {
    console.log('Opravuji ƒçastou chybu detekce:', barcode, '‚Üí', commonMisreads[barcode]);
    barcode = commonMisreads[barcode];
    }

  // Validace form√°tu a checksumu
  const isValid = isValidEAN(barcode);
  
  if (!isValid) {
    console.log('Neplatn√Ω form√°t nebo checksum k√≥du:', barcode);
    barcodeStatus.textContent = `Neplatn√Ω k√≥d: ${barcode}`;
    barcodeStatus.style.color = 'orange';
    return;
  }
  
  // Pokud v≈°e projde, ulo≈æ√≠me a zpracujeme k√≥d
  lastDetectedBarcode = barcode;
  barcodeStatus.textContent = `Nalezen k√≥d: ${barcode}`;
  barcodeStatus.style.color = '#4CAF50';

  // Vizu√°ln√≠ feedback
  barcodeOverlay.classList.add('barcode-found');
  
  // Zastav√≠me skenov√°n√≠
  if (quaggaInitialized) {
    Quagga.stop();
  }
  
  // Po kr√°tk√© prodlevƒõ zav≈ôeme skener a vyhled√°me
  setTimeout(() => {
    closeBarcodeScanner();
    searchByBarcode(barcode);
  }, 1000);
  
  // Odstran√≠me animaci po dokonƒçen√≠
  setTimeout(() => {
    barcodeOverlay.classList.remove('barcode-found');
  }, 1500);

    // P≈ôidejte do handleBarcodeDetected
    if (barcode === '12526048' && expectedCode === '8595229926818') {
        console.log('Opravuji detekovan√Ω k√≥d na spr√°vn√Ω');
        barcode = '8595229926818'; // MANU√ÅLN√ç OPRAVA
    }

    
if (commonMisreads[barcode]) {
    console.log('Opravuji ƒçastou chybu detekce:', barcode, '‚Üí', commonMisreads[barcode]);
    barcode = commonMisreads[barcode];
}

    if (!isValidEAN && !isValidUPC) {
        console.log('Ignoruji neplatn√Ω form√°t k√≥du:', barcode);
        return;
    }
    
    // DODATEƒåN√Å KONTROLA - EAN checksum validation
    if (!validateEANChecksum(barcode)) {
        console.log('Neplatn√Ω checksum pro k√≥d:', barcode);
        return;
    }
    
    // Vizu√°ln√≠ feedback
    barcodeOverlay.classList.add('barcode-found');
    barcodeStatus.textContent = `Nalezen k√≥d: ${barcode}`;
    barcodeStatus.style.color = '#4CAF50';
    
    // Zastav√≠me skenov√°n√≠
    if (quaggaInitialized) {
        Quagga.stop();
    }
    
    // Po kr√°tk√© prodlevƒõ zav≈ôeme skener a vyhled√°me
    setTimeout(() => {
        closeBarcodeScanner();
        searchByBarcode(barcode);
    }, 1000);
}

// P≈òIDEJTE VALIDAƒåN√ç FUNKCI PRO EAN
function validateEANChecksum(barcode) {
    if (barcode.length !== 8 && barcode.length !== 13) {
        console.log('Neplatn√° d√©lka k√≥du:', barcode.length);
        return false;
    }
    
    const digits = barcode.split('').map(Number);
    const checksumDigit = digits.pop();
    
    let sum = 0;
    
    if (barcode.length === 8) {
        // EAN-8: v√°hy 3, 1, 3, 1, 3, 1, 3
        for (let i = 0; i < digits.length; i++) {
            sum += digits[i] * (i % 2 === 0 ? 3 : 1);
        }
    } else {
        // EAN-13: v√°hy 1, 3, 1, 3, ...
        for (let i = 0; i < digits.length; i++) {
            sum += digits[i] * (i % 2 === 0 ? 1 : 3);
        }
    }
    
    const calculatedChecksum = (10 - (sum % 10)) % 10;
    const isValid = calculatedChecksum === checksumDigit;
    
    if (!isValid) {
        console.log('Checksum neplatn√Ω:', {
            k√≥d: barcode,
            oƒçek√°van√Ω: checksumDigit,
            vypoƒçten√Ω: calculatedChecksum,
            suma: sum
        });
    }
    
    return isValid;
}

// P≈ôepnut√≠ kamery (p≈ôedn√≠/zadn√≠)
async function toggleCamera() {
    facingMode = facingMode === 'environment' ? 'user' : 'environment';
    barcodeStatus.textContent = 'P≈ôep√≠n√°m kameru...';
    
    try {
        await startCamera();
        barcodeStatus.textContent = 'Nami≈ôte na ƒç√°rov√Ω k√≥d';
        
        // Restart Quagga s novou kamerou
        if (quaggaInitialized) {
            Quagga.stop();
            initQuagga();
            startBarcodeScanning();
        }
    } catch (error) {
        console.error('Chyba p≈ôi p≈ôep√≠n√°n√≠ kamery:', error);
        barcodeStatus.textContent = 'Chyba: ' + error.message;
        barcodeStatus.style.color = 'red';
    }
}

// P≈ôepnut√≠ blesku (pokud je dostupn√Ω)
async function toggleFlash() {
    if (!stream) return;
    
    const videoTrack = stream.getVideoTracks()[0];
    if (!videoTrack) return;
    
    try {
        const capabilities = videoTrack.getCapabilities();
        if (capabilities.torch) {
            await videoTrack.applyConstraints({
                advanced: [{ torch: !flashEnabled }]
            });
            flashEnabled = !flashEnabled;
            document.getElementById('toggleFlashButton').textContent = 
                flashEnabled ? 'Vypnout blesk' : 'Blesk';
        } else {
            barcodeStatus.textContent = 'Blesk nen√≠ dostupn√Ω';
            barcodeStatus.style.color = 'orange';
            setTimeout(() => {
                if (barcodeModal.style.display === 'flex') {
                    barcodeStatus.textContent = 'Nami≈ôte na ƒç√°rov√Ω k√≥d';
                    barcodeStatus.style.color = '#666';
                }
            }, 2000);
        }
    } catch (error) {
        console.error('Chyba p≈ôi ovl√°d√°n√≠ blesku:', error);
    }
}

// Zav≈ôen√≠ skeneru ƒç√°rov√Ωch k√≥d≈Ø
function closeBarcodeScanner() {
    console.log('Zav√≠r√°m skener...');
    
    // Zastav√≠me ƒçasov√Ω limit
    if (detectionTimeout) {
        clearTimeout(detectionTimeout);
        detectionTimeout = null;
    }
    
    // Zastav√≠me skenov√°n√≠
    stopBarcodeScanning();
    
    // Zastav√≠me stream videa
    if (stream) {
        try {
            stream.getTracks().forEach(track => {
                track.stop();
                console.log('Zastaven track:', track.kind);
            });
            stream = null;
        } catch (error) {
            console.error('Chyba p≈ôi zastavov√°n√≠ streamu:', error);
        }
    }
    
    // Zastav√≠me video
    if (barcodeVideo) {
        barcodeVideo.srcObject = null;
    }
    
    // RESTARTUJEME QUAGGU PRO P≈ò√ç≈†T√ç POU≈ΩIT√ç
    restartQuagga();
    
    // Skryjeme mod√°ln√≠ okno
    barcodeModal.style.display = 'none';
    
    // Skryjeme tlaƒç√≠tko "Zastavit"
    document.getElementById('stopScanButton').style.display = 'none';
    
    // Obnov√≠me v√Ωchoz√≠ zobrazen√≠
    document.getElementById('barcodeUnsupportedMessage').style.display = 'block';
    barcodeVideo.style.display = 'none';
    document.getElementById('toggleCameraButton').style.display = 'none';
    document.getElementById('toggleFlashButton').style.display = 'none';
    barcodeOverlay.style.display = 'none';
    
    console.log('Skener √∫spƒõ≈°nƒõ uzav≈ôen');
}

        initializeFirebase();

        document.addEventListener('DOMContentLoaded', (event) => {
            console.log('DOMContentLoaded fired.');

            // --- Logika vyhled√°v√°n√≠ potravin ---
            const searchForm = document.getElementById('searchForm');
            if (searchForm) {
                searchForm.addEventListener('submit', async function(event) {
                    console.log('Search form submit event fired.');
                    event.preventDefault();

                    const query = document.getElementById('query').value;
                    const resultsDiv = document.getElementById('results');
                    const loadingDiv = document.getElementById('loading');
                    const errorDiv = document.getElementById('error-message');

                    resultsDiv.innerHTML = '';
                    errorDiv.innerHTML = '';
                    loadingDiv.style.display = 'block';

                    try {
                        const response = await fetch('/search', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                            },
                            body: `query=${encodeURIComponent(query)}`
                        });

                        if (!response.ok) {
                            loadingDiv.style.display = 'none';
                            let errorData;
                            try {
                                errorData = await response.json();
                            } catch (e) {
                                errorData = { error: await response.text() };
                            }
                            errorDiv.textContent = `Chyba: ${errorData.error || response.statusText}`;
                            return;
                        }

                        const reader = response.body.getReader();
                        const decoder = new TextDecoder('utf-8');
                        let buffer = '';

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) {
                                break;
                            }

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop();

                            for (const line of lines) {
                                if (line.trim() === '') continue;
                                try {
                                    const item = JSON.parse(line);
                                    if (item.error) {
                                        errorDiv.textContent = `Chyba ze serveru: ${item.error}`;
                                        loadingDiv.style.display = 'none';
                                        return;
                                    }
                                    appendFoodItem(item);
                                } catch (e) {
                                    console.error('Chyba p≈ôi parsov√°n√≠ JSON ≈ô√°dku:', e, '≈ò√°dek:', line);
                                }
                            }
                        }
                        if (buffer.trim() !== '') {
                            try {
                                const item = JSON.parse(buffer);
                                if (item.error) {
                                    errorDiv.textContent = `Chyba ze serveru: ${item.error}`;
                                } else {
                                    appendFoodItem(item);
                                }
                            } catch (e) {
                                console.error('Chyba p≈ôi parsov√°n√≠ zbytku JSON bufferu:', e, 'Buffer:', buffer);
                            }
                        }

                        loadingDiv.style.display = 'none';
                        if (resultsDiv.innerHTML === '') {
                            resultsDiv.innerHTML = '<p>Nic nenalezeno.</p>';
                        }

                    } catch (error) {
                        console.error('Do≈°lo k chybƒõ:', error);
                        loadingDiv.style.display = 'none';
                        errorDiv.textContent = 'Do≈°lo k chybƒõ p≈ôi komunikaci se serverem.';
                    }
                });
            } else {
                console.error('Search form element with ID "searchForm" not found.');
            }

            function appendFoodItem(item) {
                // Filter out recipes - only show 'potravina'
                if (item.food_type !== 'potravina') {
                    return;
                }

                const resultsDiv = document.getElementById('results');
                const foodItemDiv = document.createElement('div');
                foodItemDiv.classList.add('food-item');

                // Keep class for styling if needed, even if only 'potravina' is shown
                if (item.food_type === 'potravina') {
                    foodItemDiv.classList.add('food-item-potravina');
                }
                // Removed else if for 'recept' as it's filtered out

                if (item.slug) {
                    foodItemDiv.dataset.slug = item.slug;
                    foodItemDiv.dataset.foodType = item.food_type;
                    // The click listener now only opens the modal
                    foodItemDiv.addEventListener('click', () => showDetailsModal(item.slug, item.name, item.image_url, item.calories, item.food_type));
                }

                let imageHtml = '';
                // Updated placeholder image path
                const placeholderImage = "{{ url_for('static', filename='icon/potraviny.png') }}";

                if (item.image_url) {
                    imageHtml = `<img src="${item.image_url}" alt="${item.name}" onerror="this.onerror=null;this.src='${placeholderImage}'" />`;
                } else {
                     imageHtml = `<img src="${placeholderImage}" alt="Bez obr√°zku" />`;
                }

                // Parse and reformat item.calories to ensure 1 decimal place
                const { number: caloriesNum, unit: caloriesUnit } = parseValueAndUnit(item.calories);
                const formattedCalories = formatNumberForDisplay(caloriesNum, caloriesUnit, true); // Pass true for isEnergyValue

                // Zmƒõnƒõn√° struktura pro um√≠stƒõn√≠ kalori√≠ pod obr√°zek a labelu vedle n√°zvu
                let itemContent = `
                    <div class="image-wrapper">
                        ${imageHtml}
                    </div>
                    <div class="food-details">
                        <h3>${item.name}</h3>
                        <div class="calories-and-type-row">
                            <p class="calories-display">Kalorie: ${formattedCalories}</p>
                            <!-- Removed foodTypeLabelHtml -->
                        </div>
                    </div>
                `;
                foodItemDiv.innerHTML = itemContent;
                resultsDiv.appendChild(foodItemDiv);
            }

            // --- Logika mod√°ln√≠ho okna pro detaily potravin ---
            const detailsModal = document.getElementById('detailsModal');
            const closeButton = detailsModal.querySelector('.close-button');
            const modalDetailsContent = document.getElementById('modalDetailsContent');

            // References to new modals
            const createRecipeModal = document.getElementById('createRecipeModal');
            const newRecipeNameInput = document.getElementById('newRecipeNameInput');
            const confirmCreateRecipeButton = document.getElementById('confirmCreateRecipeButton');
            const cancelCreateRecipeButton = document.getElementById('cancelCreateRecipeButton');

            const selectRecipeModal = document.getElementById('selectRecipeModal');
            const existingRecipesList = document.getElementById('existingRecipesList');
            // const cancelSelectRecipeButton = document.getElementById('cancelSelectRecipeButton'); // Removed
            // const addNewRecipeButton = document.getElementById('addNewRecipeButton'); // Removed

            // References to settings modal elements
            const settingsIcon = document.getElementById('settingsIcon');
            const settingsModal = document.getElementById('settingsModal');
            const closeSettingsModalButton = document.getElementById('closeSettingsModal');
            const confirmRecipeCreationToggle = document.getElementById('confirmRecipeCreationToggle'); // New toggle
            const confirmFoodAdditionToggle = document.getElementById('confirmFoodAdditionToggle'); // New toggle
            const confirmDeleteRecipeToggle = document.getElementById('confirmDeleteRecipeToggle'); // New toggle for delete confirmation
            const confirmDeleteRecipeItemToggle = document.getElementById('confirmDeleteRecipeItemToggle'); // NEW toggle
            const confirmSaveChangesToggle = document.getElementById('confirmSaveChangesToggle'); // NEW
            const confirmRecipeSaveSuccessToggle = document.getElementById('confirmRecipeSaveSuccessToggle'); // NEW

            // currentFoodItemData is now in global scope
            // let currentFoodItemData = null; // To store data of the food item being processed

            // Event listener for the toggle switch in the settings modal for recipe creation
            if (confirmRecipeCreationToggle) {
                confirmRecipeCreationToggle.addEventListener('change', () => {
                    userSettings.confirmRecipeCreation = confirmRecipeCreationToggle.checked;
                    saveUserSettings(); // Save to Firestore
                    console.log("Potvrzen√≠ vytvo≈ôen√≠ receptu povoleno:", userSettings.confirmRecipeCreation);
                });
            }

            // Event listener for the toggle switch in the settings modal for food addition
            if (confirmFoodAdditionToggle) {
                confirmFoodAdditionToggle.addEventListener('change', () => {
                    userSettings.confirmFoodAddition = confirmFoodAdditionToggle.checked;
                    saveUserSettings(); // Save to Firestore
                    console.log("Potvrzen√≠ p≈ôid√°n√≠ potraviny povoleno:", userSettings.confirmFoodAddition);
                });
            }

            // Event listener for the toggle switch in the settings modal for delete confirmation
            if (confirmDeleteRecipeToggle) {
                confirmDeleteRecipeToggle.addEventListener('change', () => {
                    userSettings.confirmDeleteRecipe = confirmDeleteRecipeToggle.checked;
                    saveUserSettings(); // Save to Firestore
                    console.log("Potvrzen√≠ smaz√°n√≠ receptu povoleno:", userSettings.confirmDeleteRecipe);
                });
            }

            // NEW: Event listener for the toggle switch in the settings modal for recipe item deletion
            if (confirmDeleteRecipeItemToggle) {
                confirmDeleteRecipeItemToggle.addEventListener('change', () => {
                    userSettings.confirmDeleteRecipeItem = confirmDeleteRecipeItemToggle.checked;
                    saveUserSettings(); // Save to Firestore
                    console.log("Potvrzen√≠ smaz√°n√≠ polo≈æky povoleno:", userSettings.confirmDeleteRecipeItem);
                });
            }

            // NEW: Event listener for the toggle switch in the settings modal for save changes confirmation
            if (confirmSaveChangesToggle) {
                confirmSaveChangesToggle.addEventListener('change', () => {
                    userSettings.confirmSaveChanges = confirmSaveChangesToggle.checked;
                    saveUserSettings(); // Save to Firestore
                    console.log("Potvrzen√≠ ulo≈æen√≠ zmƒõn povoleno:", userSettings.confirmSaveChanges);
                });
            }

            // NEW: Event listener for the toggle switch in the settings modal for successful save notification
            if (confirmRecipeSaveSuccessToggle) {
                confirmRecipeSaveSuccessToggle.addEventListener('change', () => {
                    userSettings.confirmRecipeSaveSuccess = confirmRecipeSaveSuccessToggle.checked;
                    saveUserSettings(); // Save to Firestore
                    console.log("Ozn√°men√≠ √∫spƒõ≈°n√©ho ulo≈æen√≠ zmƒõn povoleno:", userSettings.confirmRecipeSaveSuccess);
                });
            }

            // New toggle for successful recipe deletion notification
            const confirmRecipeDeletionSuccessToggle = document.getElementById('confirmRecipeDeletionSuccessToggle');
            if (confirmRecipeDeletionSuccessToggle) {
                confirmRecipeDeletionSuccessToggle.addEventListener('change', () => {
                    userSettings.confirmRecipeDeletionSuccess = confirmRecipeDeletionSuccessToggle.checked;
                    saveUserSettings();
                    console.log("Potvrzen√≠ √∫spƒõ≈°n√©ho smaz√°n√≠ povoleno:", userSettings.confirmRecipeDeletionSuccess);
                });
            }

            // New toggle for recipe deletion error notification
            const confirmRecipeDeletionErrorToggle = document.getElementById('confirmRecipeDeletionErrorToggle');
            if (confirmRecipeDeletionErrorToggle) {
                confirmRecipeDeletionErrorToggle.addEventListener('change', () => {
                    userSettings.confirmRecipeDeletionError = confirmRecipeDeletionErrorToggle.checked;
                    saveUserSettings();
                    console.log("Potvrzen√≠ chyby smaz√°n√≠ povoleno:", userSettings.confirmRecipeDeletionError);
                });
            }

            if (closeButton) {
                closeButton.addEventListener('click', () => {
                    detailsModal.style.display = 'none';
                    // Reset current editing context when closing the modal
                    currentEditingRecipeId = null;
                    currentEditingIngredientIndex = null;
                });
            }

            window.addEventListener('click', (event) => {
                if (event.target == detailsModal) {
                    detailsModal.style.display = 'none';
                    // Reset current editing context when closing the modal
                    currentEditingRecipeId = null;
                    currentEditingIngredientIndex = null;
                }
                if (event.target == settingsModal) { // Close settings modal if clicked outside
                    settingsModal.style.display = 'none';
                }
                // Close custom notification modal if clicked outside, unless it's a confirmation type
                if (event.target == customNotificationModal && customNotificationModal.style.display === 'flex') {
                    // If it's a confirmation, don't close on outside click.
                    // This requires a way to know if it's a confirmation.
                    // For now, let's assume all custom notifications can be closed by outside click.
                    // A more robust solution would be to add a data attribute to the modal when it's a confirmation.
                    customNotificationModal.style.display = 'none';
                }
                // Close selectRecipeModal if clicked outside
                if (event.target == selectRecipeModal) {
                    selectRecipeModal.style.display = 'none';
                }
                // Close barcodeModal if clicked outside
                if (event.target == barcodeModal) {
                    closeBarcodeScanner();
                }
            });

            // Close new modals
            document.getElementById('closeCreateRecipeModal').addEventListener('click', () => {
                createRecipeModal.style.display = 'none';
            });

            // Event listener for confirming new recipe creation
            if (confirmCreateRecipeButton) { // Add check for existence
                confirmCreateRecipeButton.onclick = async () => {
                    const recipeName = newRecipeNameInput.value.trim();
                    if (recipeName) {
                        await createNewRecipe(recipeName, currentFoodItemData);
                        createRecipeModal.style.display = 'none';
                    } else {
                        showCustomNotification("Pros√≠m, zadejte n√°zev receptu.", 'validationError');
                    }
                };
            }

            // Event listener for canceling new recipe creation
            if (cancelCreateRecipeButton) { // Add check for existence
                cancelCreateRecipeButton.addEventListener('click', () => {
                    createRecipeModal.style.display = 'none';
                });
            }

            document.getElementById('closeSelectRecipeModal').addEventListener('click', () => {
                selectRecipeModal.style.display = 'none';
            });

            // Settings icon click listener
            if (settingsIcon) {
                settingsIcon.addEventListener('click', () => {
                    settingsModal.style.display = 'flex';
                });
            }

            // Close settings modal button
            if (closeSettingsModalButton) {
                closeSettingsModalButton.addEventListener('click', () => {
                    settingsModal.style.display = 'none';
                });
            }

        }); // End of DOMContentLoaded

        async function showDetailsModal(slug, name, imageUrl, initialCaloriesString, foodType, isEditingRecipeIngredient = false, initialAmount = 100, initialUnit = 'g', originalNutritionalDetails = null) {
            console.log("showDetailsModal called for slug:", slug, "name:", name, "foodType:", foodType, "isEditingRecipeIngredient:", isEditingRecipeIngredient);
            modalDetailsContent.classList.remove('modal-recipe-container'); // Odebere t≈ô√≠du pro potraviny
            document.getElementById('modalDetailsContent').classList.remove('modal-recipe-container');
            detailsModal.style.display = 'flex'; // Ensure modal is visible
            modalDetailsContent.innerHTML = `<p class="loading-details">Naƒç√≠t√°m detaily pro ${name}...</p>`;

            try {
                let details;
                if (isEditingRecipeIngredient && originalNutritionalDetails) {
                    // If editing an ingredient, use the provided nutritional details directly
                    details = originalNutritionalDetails;
                    console.log("Using provided nutritional details for editing:", details);
                } else {
                    // Otherwise, fetch details from the server
                    const response = await fetch('/get_details', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ slug: slug, food_type: foodType })
                    });

                    console.log("Response status:", response.status);

                    if (!response.ok) {
                        let errorMessage = `Chyba p≈ôi naƒç√≠t√°n√≠ detail≈Ø (Status: ${response.status}).`;
                        let rawResponseText = await response.text();
                        console.error("Raw server response (not OK):", rawResponseText);
                        try {
                            const errorData = JSON.parse(rawResponseText);
                            if (errorData && errorData.error) {
                                errorMessage = `Chyba ze serveru: ${errorData.error}`;
                            } else {
                                errorMessage = `Chyba ze serveru (nezn√°m√Ω form√°t odpovƒõdi).`;
                            }
                        } catch (jsonParseError) {
                            errorMessage = `Chyba p≈ôi komunikaci se serverem: ${response.statusText || 'Nezn√°m√° chyba'}. Odpovƒõƒè serveru nebyla platn√Ω JSON.`;
                            console.error("Nepoda≈ôilo se parsovat odpovƒõƒè serveru jako JSON:", jsonParseError);
                        }
                        modalDetailsContent.innerHTML = `<p class="error-details">${errorMessage}</p>`;
                        return;
                    }
                    details = await response.json();
                    console.log("Received details JSON:", details);
                }

                let originalDetailsData = details;

                if (details.error) {
                    modalDetailsContent.innerHTML = `<p class="error-details">Chyba ze serveru: ${details.error}</p>`;
                } else {
                    // Updated placeholder image path
                    const placeholderImage = "{{ url_for('static', filename='icon/potraviny.png') }}";
                    let displayImageUrl = imageUrl || placeholderImage;

                    const { unit: initialUnitForTypeDetection } = parseValueAndUnit(initialCaloriesString);
                    const isLiquidFood = initialUnitForTypeDetection.toLowerCase().includes('ml');

                    let actionButtonsHtml = '';
                    if (isEditingRecipeIngredient) {
                        actionButtonsHtml = `
                            <div class="modal-action-buttons">
                                <button id="saveChangesButton" style="background-color: #28a745;">Ulo≈æit zmƒõny</button>
                                <button id="discardChangesButton" style="background-color: #dc3545;">Zahodit zmƒõny</button>
                            </div>
                        `;
                    } else {
                        actionButtonsHtml = `
                            <div class="modal-action-buttons">
                                <button id="addToRecipeButton">P≈ôidat do receptu</button>
                                <button id="createAndAddRecipeButton">Vytvo≈ôit recept a p≈ôidat</button>
                            </div>
                        `;
                    }

                    let detailsHtml = `
                        <div class="modal-header-content">
                            <img id="modalHeaderImage" src="${displayImageUrl}" alt="${name}" class="modal-header-image" onerror="this.onerror=null;this.src='${placeholderImage}'" />
                            <div id="modalHeaderName" class="modal-header-name">${name}</div>
                        </div>
                        ${actionButtonsHtml}
                        <div class="interactive-section">
                            <div class="amount-controls">
                                <input type="number" id="amountInput" value="${initialAmount}" min="0" step="1" class="amount-input">
                                <select id="unitSelect" class="unit-select">
                                    <!-- Options will be dynamically added here -->
                                </select>
                            </div>
                            <div class="energy-display-group">
                                <div id="totalKcalDisplay" class="energy-header"></div>
                                <div id="totalKjDisplay" class="energy-sub-header"></div>
                            </div>
                        </div>
                        <div id="nutrientDetailsSection">
                            <!-- Nutrients will be rendered here by renderAllNutrientDetails -->
                        </div>
                        ${details.source_url ? `<p style="text-align: center; margin-top: 20px;"><a href="${details.source_url}" target="_blank">Zobrazit na Kalorick√©Tabulky.cz</a></p>` : ''}
                    `;
                    modalDetailsContent.innerHTML = detailsHtml;

                    // Re-get references to elements after innerHTML is set
                    const amountInput = document.getElementById('amountInput');
                    const unitSelect = document.getElementById('unitSelect');
                    const addToRecipeButton = document.getElementById('addToRecipeButton'); // May be null
                    const createAndAddRecipeButton = document.getElementById('createAndAddRecipeButton'); // May be null
                    const saveChangesButton = document.getElementById('saveChangesButton'); // May be null
                    const discardChangesButton = document.getElementById('discardChangesButton'); // May be null

                    unitSelect.innerHTML = '';
                    if (isLiquidFood) {
                        unitSelect.add(new Option('ml', 'ml'));
                        unitSelect.add(new Option('l', 'l'));
                        unitSelect.value = initialUnit;
                    } else {
                        unitSelect.add(new Option('g', 'g'));
                        unitSelect.add(new Option('kg', 'kg'));
                        unitSelect.value = initialUnit;
                    }

                    const updateDisplay = () => {
                        const currentAmount = parseFloat(amountInput.value) || 0;
                        const selectedUnit = unitSelect.value;
                        let baseAmount = currentAmount;

                        if (selectedUnit === 'kg') {
                            baseAmount = currentAmount * 1000;
                        } else if (selectedUnit === 'l') {
                            baseAmount = currentAmount * 1000;
                        }

                        let factor = baseAmount / 100;

                        renderAllNutrientDetails(originalDetailsData, factor);

                        // Update currentFoodItemData with the latest calculated values for saving/adding
                        currentFoodItemData = {
                            foodName: name,
                            slug: slug,
                            imageUrl: displayImageUrl,
                            foodType: foodType,
                            amount: currentAmount,
                            unit: selectedUnit,
                            kcal: document.getElementById('totalKcalDisplay').textContent, // Store the calculated kcal
                            nutritionalDetails: originalDetailsData // Store the full nutritional details
                        };
                    };

                    amountInput.addEventListener('input', updateDisplay);
                    unitSelect.addEventListener('change', updateDisplay);

                    updateDisplay(); // Initial display update

                    // Event listeners for buttons
                    if (addToRecipeButton) {
                        addToRecipeButton.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            console.log('P≈ôidat do receptu clicked for:', name);
                            if (!isAuthReady || !userId) {
                                showCustomNotification("Pros√≠m, poƒçkejte, ne≈æ se aplikace inicializuje a p≈ôihl√°s√≠.", 'info');
                                return;
                            }
                            await loadUserRecipes(true); // Load recipes before showing selection modal, pass true for adding
                            detailsModal.style.display = 'none'; // Hide details modal
                            selectRecipeModal.style.display = 'flex'; // Show select recipe modal
                        });
                    }
                    if (createAndAddRecipeButton) {
                        createAndAddRecipeButton.addEventListener('click', (e) => {
                            e.stopPropagation();
                            console.log('Vytvo≈ôit recept a p≈ôidat clicked for:', name);
                            if (!isAuthReady || !userId) {
                                showCustomNotification("Pros√≠m, poƒçkejte, ne≈æ se aplikace inicializuje a p≈ôihl√°s√≠.", 'info');
                                return;
                            }
                            detailsModal.style.display = 'none'; // Hide details modal
                            createRecipeModal.style.display = 'flex'; // Show create recipe modal
                            newRecipeNameInput.value = ''; // Clear input
                            newRecipeNameInput.focus();
                        });
                    }

                    if (saveChangesButton) {
                        saveChangesButton.addEventListener('click', async () => {
                            if (currentEditingRecipeId && currentEditingIngredientIndex !== null) {
                                await updateFoodItemInRecipe(currentEditingRecipeId, currentEditingIngredientIndex, currentFoodItemData);
                                // The modal closing and recipe details reloading is now handled within updateFoodItemInRecipe's success callback
                            } else {
                                showCustomNotification("Chyba: Nelze ulo≈æit zmƒõny. Chyb√≠ kontext √∫pravy.", 'info');
                            }
                        });
                    }

                    if (discardChangesButton) {
                        discardChangesButton.addEventListener('click', async () => {
                            detailsModal.style.display = 'none';
                            // Optionally, reload the original recipe details if needed
                            if (currentEditingRecipeId) {
                                const recipeDocRef = doc(db, `artifacts/${appId}/users/${userId}/recipes`, currentEditingRecipeId);
                                const recipeSnap = await getDoc(recipeDocRef);
                                if (recipeSnap.exists()) {
                                    await showRecipeDetailsModal(currentEditingRecipeId, recipeSnap.data().name);
                                }
                            }
                            // Reset current editing context
                            currentEditingRecipeId = null;
                            currentEditingIngredientIndex = null;
                        });
                    }

                    const modalHeaderImage = document.getElementById('modalHeaderImage');
                    const modalHeaderName = document.getElementById('modalHeaderName');

                    if (modalHeaderImage && modalHeaderName) {
                        const imageHeight = modalHeaderImage.offsetHeight;
                        let currentFontSize = imageHeight * 0.25;
                        modalHeaderName.style.fontSize = `${currentFontSize}px`;

                        while ((modalHeaderName.scrollWidth > modalHeaderName.clientWidth || modalHeaderName.scrollHeight > modalHeaderName.clientHeight) && currentFontSize > 10) {
                            currentFontSize -= 0.5;
                            modalHeaderName.style.fontSize = `${currentFontSize}px`;
                        }
                    }
                }

            } catch (error) {
                console.error('Chyba p≈ôi z√≠sk√°v√°n√≠ detail≈Ø:', error);
                modalDetailsContent.innerHTML = `<p class="error-details">Do≈°lo k chybƒõ p≈ôi komunikaci se serverem pro detaily.</p>`;
            }
        }

        // --- Logika pro tlaƒç√≠tko "Recepty" a mod√°ln√≠ okno s mo≈ænostmi recept≈Ø ---
        const recipesButton = document.getElementById('recipesButton');

        // Modified recipesButton listener
        if (recipesButton) {
            recipesButton.addEventListener('click', async () => {
                if (!isAuthReady || !userId) {
                    showCustomNotification("Pros√≠m, poƒçkejte, ne≈æ se aplikace inicializuje a p≈ôihl√°s√≠.", 'info');
                    return;
                }
                await loadUserRecipes(); // Load recipes when "Recepty" button is clicked
                selectRecipeModal.style.display = 'flex'; // Show the select recipe modal directly
            });
        }

    </script>
    
    <!-- Load QuaggaJS for barcode scanning -->
    <script src="https://cdn.jsdelivr.net/npm/quagga@0.12.1/dist/quagga.min.js"></script>
</body>
</html>